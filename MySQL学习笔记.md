# MySQL学习笔记

## 1. 基础篇

### 1.1 MySQL概述

数据库(DB)：数据存储的仓库，数据有组织的存储

数据库管理系统(DBMS)：操纵和管理数据库的大型软件,DataBase Management System

SQL:操作关系型数据库的编程语言，定义了一套操作关系型数据库统一**标准**,Structed Query Language

**MySQL的启动与停止：**

```shell
net start mysql80
net stop mysql80
```

**MySQL客户端连接：**

```shell
mysql -u root -p
```

- **关系型数据库(RDBMS)**

  概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库

  特点：

  1. 使用表存储数据，格式统一便于维护
  2. 使用SQL语言操作，标准统一，使用方便

### 1.2 SQL

- **SQL通用语法**
  1. SQL语句可以单行或多行书写，以分号结尾
  2. SQL语句可以使用空格/缩进来增强语句的可读性
  3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写
  4. 注释：
     - 单行注释：-- 注释内容 或 #注释内容（SQL特有）
     - 多行注释 ：/* 注释内容 */
- **SQL分类**

| 分类 | 全称                       | 说明                                                   |
| ---- | -------------------------- | ------------------------------------------------------ |
| DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |
| DML  | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改         |
| DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |
| DCL  | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

#### 1.2.1 DDL语句

##### **数据库操作**

- **查询**

​	查询所有数据库

```sql
SHOW DATABASES;
```

​	查询当前数据库

```SQL
SELECT DATABASE();
```

- 创建 

```sql
CREATE DATABASE [IF NOT EXISTS] 数据库名 [DFAULT CHARSET 字符集] [COLLATE 排序规则];
```

- 删除

```sql
DROP DATABASE [IF EXISTS] 数据库名;
```

- 使用

```sql
USE  數據庫名;
```

##### 表操作

- **查询**

  查询当前数据库所有表

  ```SQL
  SHOW TABLES;
  ```

  查询表结构

  ```sql
  DESC 表名;
  ```

  查询指定表的建表语句

  ```sql
  SHOW CREATE TABLE 表名
  ```

- **创建**

```sql
CREATE TABLE 表名(
	字段1 字段1类型[COMMENT 字段1注释]，
	字段2 字段2类型[COMMENT 字段2注释]，
	字段3 字段3类型[COMMENT 字段3注释]，
	......
	字段N 字段N类型[COMMENT 字段N注释]
)[COMMENT 表注释];
```

**注意：最后一个字段不要加逗号！**

```SQL
mysql> CREATE TABLE TB_HUD(
    -> ID INT COMMENT '编号',
    -> NAME VARCHAR(50) COMMENT '姓名',
    -> AGE INT COMMENT '年龄',
    -> GENDER VARCHAR(1) COMMENT '性别'
    -> ) COMMENT '用户表';
```

**案例：根据需求创建表(设计合理的数据长度、类型)**

设计一张员工信息表，要求如下：

1. 編號(纯数字)
2. 员工工号(字符串类型，长度不超过10位)
3. 员工姓名(字符串类型，长度不超过10位)
4. 性别(男/女，存储一个汉字)
5. 年龄(正常年龄，没有负数)
6. 身份证号码(18位)
7. 入职时间(取值年月日)

```sql
mysql> CREATE TABLE EMP(
    ->      ID INT,
    ->      WORKNUM VARCHAR(10),
    ->      NAME VARCHAR(10),
    ->      GEN CHAR(1),
    ->      AGE TINYINT UNSIGNED,
    ->      IDCARD CHAR(18),
    ->      ENTD DATE COMMENT '入职时间'
    -> ) COMMENT '员工表';
 
mysql> DESC EMP;
+---------+------------------+------+-----+---------+-------+
| Field   | Type             | Null | Key | Default | Extra |
+---------+------------------+------+-----+---------+-------+
| ID      | int              | YES  |     | NULL    |       |
| WORKNUM | varchar(10)      | YES  |     | NULL    |       |
| NAME    | varchar(10)      | YES  |     | NULL    |       |
| GEN     | char(1)          | YES  |     | NULL    |       |
| AGE     | tinyint unsigned | YES  |     | NULL    |       |
| IDCARD  | char(18)         | YES  |     | NULL    |       |
| ENTD    | date             | YES  |     | NULL    |       |
+---------+------------------+------+-----+---------+-------+
```

- **修改**

​		向表结构中添加字段

```sql
ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];
```

例如，在emp表中增加一个新的字段"昵称"为nickname，类型为varchar(20)

```sql
mysql> ALTER TABLE EMP ADD NICKNAME VARCHAR(20) COMMENT '昵称';
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> desc emp;
+----------+------------------+------+-----+---------+-------+
| Field    | Type             | Null | Key | Default | Extra |
+----------+------------------+------+-----+---------+-------+
| ID       | int              | YES  |     | NULL    |       |
| WORKNUM  | varchar(10)      | YES  |     | NULL    |       |
| NAME     | varchar(10)      | YES  |     | NULL    |       |
| GEN      | char(1)          | YES  |     | NULL    |       |
| AGE      | tinyint unsigned | YES  |     | NULL    |       |
| IDCARD   | char(18)         | YES  |     | NULL    |       |
| ENTD     | date             | YES  |     | NULL    |       |
| NICKNAME | varchar(20)      | YES  |     | NULL    |       |
+----------+------------------+------+-----+---------+-------+
```

​		**修改表中的字段（数据类型）**

```sql
ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)
```

```sql
mysql> ALTER TABLE EMP MODIFY NICKNAME CHAR(10);
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC EMP;
+----------+------------------+------+-----+---------+-------+
| Field    | Type             | Null | Key | Default | Extra |
+----------+------------------+------+-----+---------+-------+
| ID       | int              | YES  |     | NULL    |       |
| WORKNUM  | varchar(10)      | YES  |     | NULL    |       |
| NAME     | varchar(10)      | YES  |     | NULL    |       |
| GEN      | char(1)          | YES  |     | NULL    |       |
| AGE      | tinyint unsigned | YES  |     | NULL    |       |
| IDCARD   | char(18)         | YES  |     | NULL    |       |
| ENTD     | date             | YES  |     | NULL    |       |
| NICKNAME | char(10)         | YES  |     | NULL    |       |
+----------+------------------+------+-----+---------+-------+
8 rows in set (0.00 sec)
```

​		**修改表中的字段名和字段类型**

```sql
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];
```

如将emp表中的nickname字段修改为enickname 类型为varchar(9):

```SQL
mysql> ALTER TABLE EMP CHANGE NICKNAME ENICKNAME VARCHAR(9);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC EMP;
+-----------+------------------+------+-----+---------+-------+
| Field     | Type             | Null | Key | Default | Extra |
+-----------+------------------+------+-----+---------+-------+
| ID        | int              | YES  |     | NULL    |       |
| WORKNUM   | varchar(10)      | YES  |     | NULL    |       |
| NAME      | varchar(10)      | YES  |     | NULL    |       |
| GEN       | char(1)          | YES  |     | NULL    |       |
| AGE       | tinyint unsigned | YES  |     | NULL    |       |
| IDCARD    | char(18)         | YES  |     | NULL    |       |
| ENTD      | date             | YES  |     | NULL    |       |
| ENICKNAME | varchar(9)       | YES  |     | NULL    |       |
+-----------+------------------+------+-----+---------+-------+
8 rows in set (0.00 sec)
```

​		**删除表中的字段**

```sql
ALTER TABLE 表名 DROP 字段名;
```

例如删除emp中的enickname

```SQL
mysql> ALTER TABLE EMP DROP ENICKNAME;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> DESC EMP;
+---------+------------------+------+-----+---------+-------+
| Field   | Type             | Null | Key | Default | Extra |
+---------+------------------+------+-----+---------+-------+
| ID      | int              | YES  |     | NULL    |       |
| WORKNUM | varchar(10)      | YES  |     | NULL    |       |
| NAME    | varchar(10)      | YES  |     | NULL    |       |
| GEN     | char(1)          | YES  |     | NULL    |       |
| AGE     | tinyint unsigned | YES  |     | NULL    |       |
| IDCARD  | char(18)         | YES  |     | NULL    |       |
| ENTD    | date             | YES  |     | NULL    |       |
+---------+------------------+------+-----+---------+-------+
7 rows in set (0.00 sec)
```

​		**修改表名**

```sql
ALTER TABLE 表名 RENAME TO 新表名;
```

将emp表的表名修改为employer

```sql
mysql> ALTER TABLE EMP RENAME TO EMPLOYER;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW TABLES;
+-----------------+
| Tables_in_huddb |
+-----------------+
| employer        |
| tb_hud          |
+-----------------+
2 rows in set (0.00 sec)
```

​		**删除表**

```sql
DROP TABLE[IF EXISTS] 表名;
```

​		**删除指定表，并重新创建该表**

```sql
TURNCATE TABLE 表名;
```

```SQL
mysql> DROP TABLE IF EXISTS TB_HUD;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW TABLES;
+-----------------+
| Tables_in_huddb |
+-----------------+
| employer        |
+-----------------+
1 row in set (0.00 sec)
```

#### 1.2.2  DML语句

**Data Manipulation Language(DML,)功能：用来对数据库中标的数据记录进行增删改操作**

##### **增加数据(INSERT)**

- 给指定的字段添加数据

  ```sql
  INSERT INTO 表名 (字段名1,字段名2,...) VALUES (值1,值2,...);
  ```

- 给全部字段添加数据

  ```sql
  INSERT INTO 表名 VALUES (值1,值2,...);	# 值1是第一个字段值，值2是第二个字段...
  ```

- 批量添加数据

  ```sql
  INSERT INTO 表名 (字段名1,字段名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);
  ```

  ```sql
  INSERT INTO 表名 VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)
  ```

  **注意：**

  - 插入数据时，指定的字段顺序需要与值得顺序是一一对应的
  - 字符串和日期型数据应该包含在引号中
  - 插入的数据大小，应该在字段的规定范围内

  ```sql
  INSERT INTO employer(ID, WORKNUM, NAME, GEN, AGE, IDCARD, ENTD) VALUES (1,'77','Hud','男',24,'320102199806062918','1998-06-06');
  
  INSERT INTO employer(ID, WORKNUM, NAME, GEN, AGE, IDCARD, ENTD) VALUES (2,'66','Monica','女',22,'320102200006042928','2000-06-04');
  
  INSERT INTO employer VALUES (3,'22','QB','男',1,'320102202110012912','2021-10-01')
  ```

  **一次添加多條數據**

  ```sql
  INSERT INTO emp VALUES (3,'22','QB','男',1,'320102202110012912','2021-10-01'),(2,'66','Monica','女',22,'320102200006042928','2000-06-04'),(3,'77','QTY','男',1,'320102199806062918','1998-06-06');
  
  mysql> select * from emp;
  +------+---------+--------+------+------+--------------------+------------+
  | ID   | WORKNUM | NAME   | GEN  | AGE  | IDCARD             | ENTD       |
  +------+---------+--------+------+------+--------------------+------------+
  |    1 | 77      | Hud    | 男   |   24 | 320102199806062918 | 1998-06-06 |
  |    3 | 22      | QB     | 男   |    1 | 320102202110012912 | 2021-10-01 |
  |    2 | 66      | Monica | 女   |   22 | 320102200006042928 | 2000-06-04 |
  |    3 | 77      | QTY    | 男   |    1 | 320102199806062918 | 1998-06-06 |
  +------+---------+--------+------+------+--------------------+------------+
  4 rows in set (0.00 sec)
  ```

##### **修改数据(UPDATAE)**

```sql
UPDATE 表名 SET 字段名1=值1 , 字段名2=值2 , ...[WHERE 條件]
```

```SQL
mysql> UPDATE EMP SET ID=4 WHERE NAME='QTY';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from emp;
+------+---------+--------+------+------+--------------------+------------+
| ID   | WORKNUM | NAME   | GEN  | AGE  | IDCARD             | ENTD       |
+------+---------+--------+------+------+--------------------+------------+
|    1 | 77      | Hud    | 男   |   24 | 320102199806062918 | 1998-06-06 |
|    3 | 22      | QB     | 男   |    1 | 320102202110012912 | 2021-10-01 |
|    2 | 66      | Monica | 女   |   22 | 320102200006042928 | 2000-06-04 |
|    4 | 77      | QTY    | 男   |    1 | 320102199806062918 | 1998-06-06 |
+------+---------+--------+------+------+--------------------+------------+
4 rows in set (0.00 sec)
```

**同時修改多个数据（id=4的 age和name修改）**

```sql
mysql> UPDATE EMP SET NAME='KING',AGE=24 WHERE ID=4;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from emp;
+------+---------+--------+------+------+--------------------+------------+
| ID   | WORKNUM | NAME   | GEN  | AGE  | IDCARD             | ENTD       |
+------+---------+--------+------+------+--------------------+------------+
|    1 | 77      | Hud    | 男   |   24 | 320102199806062918 | 1998-06-06 |
|    3 | 22      | QB     | 男   |    1 | 320102202110012912 | 2021-10-01 |
|    2 | 66      | Monica | 女   |   22 | 320102200006042928 | 2000-06-04 |
|    4 | 77      | KING   | 男   |   24 | 320102199806062918 | 1998-06-06 |
+------+---------+--------+------+------+--------------------+------------+
4 rows in set (0.00 sec)
```

**将所有员工的入职时间修改为2022-8-15**

如果不带[where条件]表示更新整张表的内容

```sql
mysql> UPDATE EMP SET ENTD = '2022-08-15';
Query OK, 4 rows affected (0.00 sec)
Rows matched: 4  Changed: 4  Warnings: 0

mysql> select * from emp;
+------+---------+--------+------+------+--------------------+------------+
| ID   | WORKNUM | NAME   | GEN  | AGE  | IDCARD             | ENTD       |
+------+---------+--------+------+------+--------------------+------------+
|    1 | 77      | Hud    | 男   |   24 | 320102199806062918 | 2022-08-15 |
|    3 | 22      | QB     | 男   |    1 | 320102202110012912 | 2022-08-15 |
|    2 | 66      | Monica | 女   |   22 | 320102200006042928 | 2022-08-15 |
|    4 | 77      | KING   | 男   |   24 | 320102199806062918 | 2022-08-15 |
+------+---------+--------+------+------+--------------------+------------+
4 rows in set (0.00 sec)
```

##### **删除数据(DELETE)**

- DELETE语句的条件可以有，也可以没有，如果没有条件则会删除整张表的所有数据

- DELETE语句不能删除某一个字段的值（可以使用UPDATE）

  **删除性别为女的行**

  ```sql
  mysql> DELETE FROM EMP WHERE GEN='女';
  Query OK, 1 row affected (0.01 sec)
  
  mysql> select * from emp;
  +------+---------+------+------+------+--------------------+------------+
  | ID   | WORKNUM | NAME | GEN  | AGE  | IDCARD             | ENTD       |
  +------+---------+------+------+------+--------------------+------------+
  |    1 | 77      | Hud  | 男   |   24 | 320102199806062918 | 2022-08-15 |
  |    3 | 22      | QB   | 男   |    1 | 320102202110012912 | 2022-08-15 |
  |    4 | 77      | KING | 男   |   24 | 320102199806062918 | 2022-08-15 |
  +------+---------+------+------+------+--------------------+------------+
  3 rows in set (0.00 sec)
  ```

  刪除所有數據：

  ```sql
  mysql> DELETE FROM EMP;
  Query OK, 3 rows affected (0.02 sec)
  
  mysql> select * from emp;
  Empty set (0.00 sec)
  ```

#### 1.2.3 DQL语句

Data Query Language(DQL)，数据查询语言用于查询数据库中表的记录

查询关键字：SELECT

```sql
SELECT
	字段列表
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
ORDER BY
	排序字段列表
UMIT
	分页参数
```

##### 基本查询

- 查询多个字段

  ```sql
  SELECT 字段1,字段2,... FROM 表名;
  SELECT * FROM 表名;
  ```

- 设置别名

  ```sql
  SELECT 字段1[AS别名1],字段2[AS别名2]...FROM 表名
  ```

- 去除重复记录

  ```sql
  SELECT DISTINCT 字段列表 FROM 表名;
  ```

**准备数据**

```sql
 create table emp(
    ->     id          int                 comment '编号',
    ->     worknum     varchar(10)         comment '工号',
    ->     name        varchar(10)         comment '姓名',
    ->     gender      char(1)             comment '性别',
    ->     age         tinyint unsigned    comment '年龄',
    ->     idcard      char(18)            comment '身份证号',
    ->     workaddress varchar(50)         comment '工作地址',
    ->     entrydate   date                comment '入职时间'
    -> )comment '员工表';
Query OK, 0 rows affected (0.01 sec)
mysql> desc emp;
+-------------+------------------+------+-----+---------+-------+
| Field       | Type             | Null | Key | Default | Extra |
+-------------+------------------+------+-----+---------+-------+
| id          | int              | YES  |     | NULL    |       |
| worknum     | varchar(10)      | YES  |     | NULL    |       |
| name        | varchar(10)      | YES  |     | NULL    |       |
| gender      | char(1)          | YES  |     | NULL    |       |
| age         | tinyint unsigned | YES  |     | NULL    |       |
| idcard      | char(18)         | YES  |     | NULL    |       |
| workaddress | varchar(50)      | YES  |     | NULL    |       |
| entrydate   | date             | YES  |     | NULL    |       |
+-------------+------------------+------+-----+---------+-------+

mysql> insert into emp
    -> values (1,'1','柳岩','女',20,'320126977536235489','北京','2000-01-01'),
    ->        (2,'2','张无忌','男',18,'336978544123659852','北京','2019-10-13'),
    ->        (3,'3','詹姆斯','男',37,'336978544123659852','洛城','1998-10-23'),
    ->        (4,'4','杜兰特','男',35,'336978544123659852','纽约','2009-06-17'),
    ->        (5,'5','斯嘉丽','女',26,'336978544123659852','美国','2012-01-02'),
    ->        (6,'6','顾清池','女',22,'320922200006042366','北京','2000-06-04'),
    ->        (7,'7','齐天宇','男',24,'320102199806062918','北京','1998-06-06'),
    ->        (8,'8','罗斯','男',30,'320102119730312918','芝加哥','1979-05-06'),
    ->        (9,'9','隆多','男',32,'320102196902052918','波士顿','1973-08-26'),
    ->        (10,'10','迪丽热巴','女',24,'320102200103262918','新疆','2008-06-06'),
    ->        (11,'11','欧文','男',31,'320187199806222934','纽约','1989-12-16'),
    ->        (12,'12','郭晶晶','女',34,'320102188625463216','北京','2011-05-29');
Query OK, 12 rows affected (0.00 sec)
Records: 12  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM EMP;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    3 | 3       | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
|    4 | 4       | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
|    5 | 5       | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|    8 | 8       | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 9       | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   11 | 11      | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   12 | 12      | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
12 rows in set (0.00 sec)
```

**满足需求**

- **查询指定字段 name,worknum,age 返回**

```sql
mysql> SELECT NAME,WORKNUM,AGE FROM EMP;
+----------+---------+------+
| NAME     | WORKNUM | AGE  |
+----------+---------+------+
| 柳岩     | 1       |   20 |
| 张无忌   | 2       |   18 |
| 詹姆斯   | 3       |   37 |
| 杜兰特   | 4       |   35 |
| 斯嘉丽   | 5       |   26 |
| 顾清池   | 6       |   22 |
| 齐天宇   | 7       |   24 |
| 罗斯     | 8       |   30 |
| 隆多     | 9       |   32 |
| 迪丽热巴 | 10      |   24 |
| 欧文     | 11      |   31 |
| 郭晶晶   | 12      |   34 |
+----------+---------+------+
12 rows in set (0.00 sec)
```

-  查询返回所有字段返回

```SQL
mysql> SELECT * FROM EMP;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    3 | 3       | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
|    4 | 4       | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
|    5 | 5       | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|    8 | 8       | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 9       | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   11 | 11      | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   12 | 12      | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
12 rows in set (0.00 sec)
```

- 查詢所有员工的工作地，起别名

```sql
mysql> SELECT WORKADDRESS AS '工作地址' FROM EMP;
+----------+
| 工作地址 |
+----------+
| 北京     |
| 北京     |
| 洛城     |
| 纽约     |
| 美国     |
| 北京     |
| 北京     |
| 芝加哥   |
| 波士顿   |
| 新疆     |
| 纽约     |
| 北京     |
+----------+
12 rows in set (0.00 sec)
```

- 查询员工的上班地址，不要重复

```sql
mysql> SELECT DISTINCT WORKADDRESS '工作地址' FROM EMP;
+----------+
| 工作地址 |
+----------+
| 北京     |
| 洛城     |
| 纽约     |
| 美国     |
| 芝加哥   |
| 波士顿   |
| 新疆     |
+----------+
7 rows in set (0.00 sec)
```

##### 条件查询

- **语法**

```sql
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

- **条件**

| 比较运算符       | 功能                                    |
| ---------------- | --------------------------------------- |
| >                | 大于                                    |
| >=               | 大于等于                                |
| <                | 小于                                    |
| <=               | 小于等于                                |
| =                | 等于                                    |
| <>或者!=         | 不等于                                  |
| BETWEEN...AND... | 在某个范围之内(含量小，最大值)          |
| IN(...)          | 在IN之后的列表中的值，多选一            |
| LIKE 占位符      | 模糊匹配(_匹配单个字符,%匹配任意个字符) |
| IS NULL          | 是NULL                                  |

| 逻辑运算符 | 功能                           |
| ---------- | ------------------------------ |
| AND或&&    | 并且(多个条件同时呢成立)       |
| OR或\|\|   | 或者(多个条件中的任意一个成立) |
| NOT或!     | 非，不是                       |

**案例演示**

​	**1.查询年龄等于24的员工**

```SQL
mysql> SELECT * FROM EMP WHERE AGE  = 24;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
2 rows in set (0.00 sec)
```

​	**2.查詢年龄小于26的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE AGE<26;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)
```

​	**3.查询年龄小于等于24的员工信息**

```sql
mysql> SELECT * FROM EMP WHERE AGE<=24;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)
```

 	4. 查询没有身份证号的员工信息

```SQL
mysql> SELECT * FROM EMP WHERE IDCARD IS NULL;
+------+---------+------+--------+------+--------+-------------+------------+
| id   | worknum | name | gender | age  | idcard | workaddress | entrydate  |
+------+---------+------+--------+------+--------+-------------+------------+
|   13 | 13      | 威少 | 男     |   19 | NULL   | 俄亥俄      | 2010-03-05 |
+------+---------+------+--------+------+--------+-------------+------------+
1 row in set (0.00 sec)
```

​	**5.查詢有身份证号的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE IDCARD IS NOT NULL;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    3 | 3       | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
|    4 | 4       | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
|    5 | 5       | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|    8 | 8       | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 9       | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   11 | 11      | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   12 | 12      | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
12 rows in set (0.00 sec)
```

​	**6.查询年龄不等于24的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE AGE != 24; # 也可以使用<>
+------+---------+--------+--------+------+--------------------+-------------+------------+
| id   | worknum | name   | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+--------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩   | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 2       | 张无忌 | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    3 | 3       | 詹姆斯 | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
|    4 | 4       | 杜兰特 | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
|    5 | 5       | 斯嘉丽 | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
|    6 | 6       | 顾清池 | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    8 | 8       | 罗斯   | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 9       | 隆多   | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   11 | 11      | 欧文   | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   12 | 12      | 郭晶晶 | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
|   13 | 13      | 威少   | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
+------+---------+--------+--------+------+--------------------+-------------+------------+
11 rows in set (0.00 sec)
```

​	**7.查询年龄在19岁(包含)到25岁(包含)之前的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE AGE >=19 &&AGE <=25;
#SELECT * FROM EMP WHERE AGE BETWEEN 19 and 25;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   13 | 13      | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
5 rows in set, 1 warning (0.00 sec)
```

​	**8.查询性别为女且年龄小于25岁的员工信息**

```sql
mysql> SELECT * FROM EMP WHERE GENDER = '女' && AGE<=25;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
3 rows in set, 1 warning (0.00 sec)
```

	9. **查询年龄等于19 或者20 或者24的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE AGE = 19 OR AGE = 20 OR AGE =24;
/* 更方便的写法用IN
SELECT * FROM EMP WHERE AGE IN (19,20,24); */
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   13 | 13      | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
4 rows in set (0.00 sec)
```

​	10.**查询姓名为两个字的员工信息**

```sql
mysql> SELECT * FROM EMP WHERE NAME LIKE '__';  #占位符
+------+---------+------+--------+------+--------------------+-------------+------------+
| id   | worknum | name | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+------+--------+------+--------------------+-------------+------------+
|    1 | 1       | 柳岩 | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    8 | 8       | 罗斯 | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 9       | 隆多 | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   11 | 11      | 欧文 | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   13 | 13      | 威少 | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
+------+---------+------+--------+------+--------------------+-------------+------------+
5 rows in set (0.00 sec)
```

​	**11.查询身份证号最后一位是4的员工信息**

```SQL
mysql> SELECT * FROM EMP WHERE IDCARD LIKE '%4';
# 也可以 SELECT * FROM EMP WHERE IDCARD LIKE '______(17個‘_’)4';
+------+---------+------+--------+------+--------------------+-------------+------------+
| id   | worknum | name | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+------+--------+------+--------------------+-------------+------------+
|   11 | 11      | 欧文 | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
+------+---------+------+--------+------+--------------------+-------------+------------+
1 row in set (0.00 sec)
```

##### 聚合函数

1. **介绍**

   将一列数据作为一个整体，进行纵向计算

2. **常见聚合函数**

   | 函数  | 功能     |
   | ----- | -------- |
   | count | 统计数量 |
   | max   | 最大值   |
   | min   | 最小值   |
   | avg   | 平均值   |
   | sum   | 求和     |

3. **语法**

```sql
SELECT 聚合函数(字段列表) FROM 表名;
```

**案例演示**

- **统计企业的员工数量**

  ```sql
  mysql> SELECT COUNT(*) AS '員工總數' FROM EMP;
  +----------+
  | 員工總數  |
  +----------+
  |       13 |
  +----------+
  1 row in set (0.00 sec)
  /*但是
  mysql> SELECT count(idcard) AS '員工總數' FROM EMP;
  +----------+
  | 員工總數 |
  +----------+
  |       12 |
  +----------+
  1 row in set (0.02 sec)
  這就説明所有的null值不参与计算
  ```

- **统计平均年龄**

  ```sql
  mysql> SELECT AVG(AGE) '平均年龄' FROM EMP;
  +----------+
  |  平均年龄 |
  +----------+
  |  27.0769 |
  +----------+
  1 row in set (0.00 sec)
  ```

- **求最大最小年齡**

  ```sql
  mysql> SELECT MAX(AGE) '最大年龄' FROM EMP;
  +----------+
  | 最大年龄 |
  +----------+
  |       37 |
  +----------+
  1 row in set (0.01 sec)
  
  mysql> SELECT MIN(AGE) '最小年龄' FROM EMP;
  +----------+
  | 最小年龄 |
  +----------+
  |       18 |
  +----------+
  1 row in set (0.00 sec)
  ```

- **统计北京地区员工年龄平均数**

  ```sql
  mysql> SELECT AVG(AGE) '北京員工平均年齡' FROM EMP WHERE WORKADDRESS = '北京';
  +------------------+
  | 北京員工平均年齡   |
  +------------------+
  |          23.6000 |
  +------------------+
  1 row in set (0.00 sec)
  ```

##### 分組查詢

1. **语法**

   ```sql
    SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件]
   ```

2. **WHERE和HAVING的区别**

   - 执行时机不同：WHERE是**分组之前进行过滤**，不满足WHERE条件，不参与分组，而HAVING是**分组之后对结果进行过滤**
   - 判断条件不同：WHERE不能对聚合函数进行判断，而HAVING可以

**分组查询案例演示**

- **根据性别分组，统计男性员工和女性员工的数量**

  ```sql
  mysql> SELECT GENDER '性別',COUNT(*)'人數' FROM EMP GROUP BY GENDER;
  +------+------+
  | 性別 | 人數 |
  +------+------+
  | 女   |    5 |
  | 男   |    8 |
  +------+------+
  2 rows in set (0.00 sec)
  ```

- **根据性别分组，统计男性员工和女性员工的平均年齡**

  ```sql
  mysql> SELECT GENDER '性別',avg(age)'平均年龄' FROM EMP GROUP BY GENDER;
  +------+----------+
  | 性別 | 平均年龄 |
  +------+----------+
  | 女   |  25.2000 |
  | 男   |  28.2500 |
  +------+----------+
  2 rows in set (0.02 sec)
  ```

- **查询年龄小于30岁的员工，根据工作地址进行分组，获取员工数量大于二的工作地址**

  ```SQL
  mysql> SELECT WORKADDRESS,COUNT(*) FROM EMP  WHERE AGE<30 GROUP BY WORKADDRESS HAVING COUNT(*)>2;
  +-------------+----------+
  | WORKADDRESS | COUNT(*) |
  +-------------+----------+
  | 北京        |        4 |
  +-------------+----------+
  1 row in set (0.00 sec)
  ```

  获取的是工作地点workaddress，需要满足的条件是年龄<30 ,根据工作地点进行分组，然后选出组中人数大于三的用HAVING

也就是说：

​		**分组之前过滤用WHERE，分组之后过滤用HAVING**

#####  排序查询

1. **语法**

   ```sql
   SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2;
   #首先按照第一个字符排序，如果相同按照第二个字段排序
   ```

2. **排序方式**

   - ASC：升序(默认值)
   - DESC：降序

**案例演示**

- 根据年龄对公司员工进行升序排序

  ```sql
  mysql> SELECT NAME,AGE FROM EMP ORDER BY AGE ASC;
  +----------+------+
  | NAME     | AGE  |
  +----------+------+
  | 张无忌   |   18 |
  | 威少     |   19 |
  | 柳岩     |   20 |
  | 顾清池   |   22 |
  | 齐天宇   |   24 |
  | 迪丽热巴 |   24 |
  | 斯嘉丽   |   26 |
  | 罗斯     |   30 |
  | 欧文     |   31 |
  | 隆多     |   32 |
  | 郭晶晶   |   34 |
  | 杜兰特   |   35 |
  | 詹姆斯   |   37 |
  +----------+------+
  13 rows in set (0.00 sec)
  
  # 如果是按照降序排序
  mysql> SELECT NAME,AGE FROM EMP ORDER BY AGE DESC;
  +----------+------+
  | NAME     | AGE  |
  +----------+------+
  | 詹姆斯   |   37 |
  | 杜兰特   |   35 |
  | 郭晶晶   |   34 |
  | 隆多     |   32 |
  | 欧文     |   31 |
  | 罗斯     |   30 |
  | 斯嘉丽   |   26 |
  | 齐天宇   |   24 |
  | 迪丽热巴 |   24 |
  | 顾清池   |   22 |
  | 柳岩     |   20 |
  | 威少     |   19 |
  | 张无忌   |   18 |
  +----------+------+
  13 rows in set (0.00 sec)
  ```

- **根据入职时间对员工进行降序排序**

  ```SQL
  mysql> SELECT NAME,ENTRYDATE FROM EMP ORDER BY ENTRYDATE DESC;
  +----------+------------+
  | NAME     | ENTRYDATE  |
  +----------+------------+
  | 张无忌   | 2019-10-13 |
  | 斯嘉丽   | 2012-01-02 |
  | 郭晶晶   | 2011-05-29 |
  | 威少     | 2010-03-05 |
  | 杜兰特   | 2009-06-17 |
  | 迪丽热巴 | 2008-06-06 |
  | 顾清池   | 2000-06-04 |
  | 柳岩     | 2000-01-01 |
  | 詹姆斯   | 1998-10-23 |
  | 齐天宇   | 1998-06-06 |
  | 欧文     | 1989-12-16 |
  | 罗斯     | 1979-05-06 |
  | 隆多     | 1973-08-26 |
  +----------+------------+
  13 rows in set (0.00 sec)
  ```

- **根据年龄对员工进行升序排序，年龄相同按照入职时间进行降序排序**

  ```SQL
  mysql> SELECT * FROM EMP ORDER BY AGE ASC,ENTRYDATE DESC;
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  |    2 | 2       | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
  |   13 | 13      | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
  |    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
  |    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
  |   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
  |    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
  |    5 | 5       | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
  |    8 | 8       | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
  |   11 | 11      | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
  |    9 | 9       | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
  |   12 | 12      | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
  |    4 | 4       | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
  |    3 | 3       | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  13 rows in set (0.00 sec)
  ```

  ##### 分页查询

  1. **语法**

     ```sql
     SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;
     ```

     - 起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数
     - 分页查询数据库的方言，不同的数据库有不同的实现，在MySQL中是LIMIT
     - 如果查询的是第一页的数据，起始索引可以省略，直接简写为limit (每页数据)

**案例演示**

- 查询第一页员工数据，每页展示8条数据

  ```SQL
  mysql> SELECT * FROM EMP LIMIT 0,8;
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name   | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  |    1 | 1       | 柳岩   | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
  |    2 | 2       | 张无忌 | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
  |    3 | 3       | 詹姆斯 | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
  |    4 | 4       | 杜兰特 | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
  |    5 | 5       | 斯嘉丽 | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
  |    6 | 6       | 顾清池 | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
  |    7 | 7       | 齐天宇 | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
  |    8 | 8       | 罗斯   | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  8 rows in set (0.00 sec)
  ```

- 查询第二页员工数据，每页展示8条数据

  ```sql
  mysql> SELECT * FROM EMP LIMIT 8,8;
  # 起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  |    9 | 9       | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
  |   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
  |   11 | 11      | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
  |   12 | 12      | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
  |   13 | 13      | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  5 rows in set (0.00 sec)
  ```


##### DQL语句案例练习

- 查询年龄为19,20,22,24的员工信息

  ```sql
  mysql> SELECT * FROM EMP WHERE AGE IN(19,20,22,24);
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  |    1 | 1       | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
  |    6 | 6       | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
  |    7 | 7       | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
  |   10 | 10      | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
  |   13 | 13      | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
  +------+---------+----------+--------+------+--------------------+-------------+------------+
  5 rows in set (0.00 sec)
  ```

- 查询性别为男，并且年龄在20-28岁(含)以内的姓名为三个字的员工

  ```sql
  mysql> SELECT * FROM EMP WHERE GENDER='男'&& AGE>20 && AGE<=28 && NAME LIKE '___';
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name   | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  |    7 | 7       | 齐天宇  | 男      |   24 | 320102199806062918 | 北京        | 1998-06-06 |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  1 row in set, 3 warnings (0.00 sec)
  ```

- 统计表中年龄小于35岁的男性和女性员工的数量

  ```SQL
  mysql> SELECT GENDER,COUNT(*) FROM EMP WHERE AGE <35 GROUP BY GENDER;
  +--------+----------+
  | GENDER | COUNT(*) |
  +--------+----------+
  | 女     |        5 |
  | 男     |        6 |
  +--------+----------+
  2 rows in set (0.00 sec)
  ```

- 查询所有年龄小于等于35岁的员工的姓名和年龄，并对查询结果按年龄进行升序排序，如果年龄相同按入职时间降序排序

  ```SQL
  mysql> SELECT NAME,AGE FROM EMP WHERE AGE <=35 ORDER BY AGE ASC,ENTRYDATE DESC;
  +----------+------+
  | NAME     | AGE  |
  +----------+------+
  | 张无忌   |   18 |
  | 威少     |   19 |
  | 柳岩     |   20 |
  | 顾清池   |   22 |
  | 迪丽热巴 |   24 |
  | 齐天宇   |   24 |
  | 斯嘉丽   |   26 |
  | 罗斯     |   30 |
  | 欧文     |   31 |
  | 隆多     |   32 |
  | 郭晶晶   |   34 |
  | 杜兰特   |   35 |
  +----------+------+
  ```

- 查詢性别为男，且年龄在20-35岁之间(含)以内的前5个员工信息，对查询结果按年龄升序排序，年龄相同按入职时间降序排序

  ```SQL
  mysql> SELECT * FROM EMP WHERE AGE BETWEEN 20 AND 35 && GENDER = '男'  ORDER BY AGE ASC,ENTRYDATE DESC LIMIT 5;
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  | id   | worknum | name   | gender | age  | idcard             | workaddress | entrydate  |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  |    7 | 7       | 齐天宇 | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
  |    8 | 8       | 罗斯   | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
  |   11 | 11      | 欧文   | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
  |    9 | 9       | 隆多   | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
  |    4 | 4       | 杜兰特 | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
  +------+---------+--------+--------+------+--------------------+-------------+------------+
  5 rows in set, 1 warning (0.00 sec)
  ```

##### DQL执行顺序

​	**FROM --> WHERE --> GROUP BY --> SELECT --> ORDER BY -->LIMIT**

   (验证方式：在执行操作之后给表起一个别名，后续操作对别名进行验证)

```sql
mysql> SELECT E.NAME ENAME ,E.AGE EAGE FROM EMP E WHERE E.AGE >20 ORDER BY EAGE ASC;
+----------+------+
| ENAME    | EAGE |
+----------+------+
| 顾清池   |   22 |
| 齐天宇   |   24 |
| 迪丽热巴 |   24 |
| 斯嘉丽   |   26 |
| 罗斯     |   30 |
| 欧文     |   31 |
| 隆多     |   32 |
| 郭晶晶   |   34 |
| 杜兰特   |   35 |
| 詹姆斯   |   37 |
+----------+------+
```

#### 1.2.4 DCL语句

Data Control Language(数据控制语言)，用来管理数据库**用户**、控制数据库的**访问权限**

##### DCL用户操作

1. 查询用户

   ```SQL
   USE MYSQL;
   SELECT * FROM USER;
   ```

2. 创建用户

   ```sql
   CREATE USER '用戶名'@'主机名’ IDENTIFIED BY '密码'
   ```

3. 修改用户密码

   ```sqL
   ALTER USER '用戶名'@'主机名’ IDENTIFIED BY mysql_native_password BY '新密碼'
   ```

4. 删除用户

   ```sql
   DROP USER '用戶名'@'主机名’
   ```

**案例演示：**

- 创建用户itcast，只能在当前主机localhost访问，密码设置为199866

  ```sql
  mysql> CREATE USER 'ITCAST'@'LOCALHOST' IDENTIFIED BY '199866';
  
  C:\Users\Hud>mysql -u ITCAST -p
  Enter password: ******
  Welcome to the MySQL monitor.  Commands end with ; or \g.
  Your MySQL connection id is 46
  Server version: 8.0.30 MySQL Community Server - GPL
  
  Copyright (c) 2000, 2022, Oracle and/or its affiliates.
  
  Oracle is a registered trademark of Oracle Corporation and/or its
  affiliates. Other names may be trademarks of their respective
  owners.
  
  Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
  
  mysql> SHOW DATABASES;
  +--------------------+
  | Database           |
  +--------------------+
  | information_schema |
  | performance_schema |
  +--------------------+
  2 rows in set (0.01 sec)
  ```

- 创建用户Hud，可以在任意主机访问该数据库，密码199866

  ```sql
  mysql> CREATE USER 'Hud'@'%' IDENTIFIED BY '199866';
  Query OK, 0 rows affected (0.01 sec)
  # 在任意主机上进行访问，使用通配符%
  ```

- 修改用户ITCAST的用户密码为‘123456’

  ```sql
  mysql> ALTER USER 'ITCAST'@'LOCALHOST'IDENTIFIED WITH MYSQL_NATIVE_PASSWORD BY '123456';
  Query OK, 0 rows affected, 1 warning (0.02 sec)
  ```

- 删除itcast@localhost用户

  ```sql
  mysql> DROP USER 'ITCAST'@'LOCALHOST';
  Query OK, 0 rows affected (0.01 sec)
  ```

**注意：**

1. 主机名可以使用%通配
2. 这类SQL开发人员操作的比较少，主要是DBA(Database Adminstrator 数据库管理员)使用。



##### DCL权限设置

​	常用的权限设置

|        权限         |        说明        |
| :-----------------: | :----------------: |
| ALL，ALL PRIVILEGES |      所有权限      |
|       SELECT        |      查询数据      |
|       INSERT        |      插入数据      |
|       UPDATE        |      修改数据      |
|       DELETE        |      删除数据      |
|        ALTER        |       修改表       |
|        DROP         | 删除数据库/表/视图 |
|       CREATE        |   创建数据库/表    |

1. 查询权限

   ```sql
   SHOW GRANTS FOR '用户名'@'主机名';
   ```

2. 授予权限

   ```sql
   GRANT 权限列表 ON 数据库/表名 TO '用户名'@'主机名'
   ```

3. 撤销权限 

   ```sql
   REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
   ```



**案例演示**

- 查询权限

  ```sql
  mysql> SHOW GRANTS FOR 'Hud'@'%';
  +---------------------------------+
  | Grants for Hud@%                |
  +---------------------------------+
  | GRANT USAGE ON *.* TO `Hud`@`%` |
  +---------------------------------+
  1 row in set (0.00 sec)
  ```

- 授予权限

  ```SQL
  mysql> SHOW GRANTS FOR 'Hud'@'%';
  +---------------------------------+
  | Grants for Hud@%                |
  +---------------------------------+
  | GRANT USAGE ON *.* TO `Hud`@`%` |
  +---------------------------------+
  1 row in set (0.00 sec)
  
  mysql> GRANT ALL ON HUDDB.EMP TO 'Hud'@'%';
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> SHOW GRANTS FOR 'Hud'@'%';
  +----------------------------------------------------+
  | Grants for Hud@%                                   |
  +----------------------------------------------------+
  | GRANT USAGE ON *.* TO `Hud`@`%`                    |
  | GRANT ALL PRIVILEGES ON `huddb`.`emp` TO `Hud`@`%` |
  +----------------------------------------------------+
  2 rows in set (0.00 sec)
  ```

- 撤销权限

  ```SQL
  mysql> REVOKE ALL ON HUDDB.EMP FROM 'Hud'@'%';
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> SHOW GRANTS FOR  'Hud'@'%';
  +---------------------------------+
  | Grants for Hud@%                |
  +---------------------------------+
  | GRANT USAGE ON *.* TO `Hud`@`%` |
  +---------------------------------+
  1 row in set (0.00 sec)
  ```

**注意：**

1. 多个权限之间使用逗号分隔
2. 授权时，数据库名和表名可以使用*进行通配，代表所有



### 1.3 函数

#### 1.3.1 字符串函数

​	比较常用的MySQL内置字符串函数

|           函数           |                           功能                            |
| :----------------------: | :-------------------------------------------------------: |
|   CONCAT(S1,S2,...,SN)   |        字符串拼接，将S1,S2,...,Sn拼接成一个字符串         |
|        LOWER(str)        |                 将字符串str全部转换为小写                 |
|        UPPER(str)        |                 将字符串str全部转换为大写                 |
|     LPAD(str,n,pad)      | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |
|     RPAD(str,n,pad)      | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 |
|        TRIM(str)         |                去掉字符串头部和尾部的空格                 |
| SUBSTRING(str,start,len) |      返回从字符串str从start位置起的len个长度的字符串      |

**案例演示**

- 字符串拼接

  ```sql
  mysql> SELECT CONCAT('HELLO','MySQL');
  +-------------------------+
  | CONCAT('HELLO','MySQL') |
  +-------------------------+
  | HELLOMySQL              |
  +-------------------------+
  1 row in set (0.00 sec)
  ```

- LOWER & UPPER

  ```sql
  mysql> SELECT LOWER('HELLO,MYSQL');
  +----------------------+
  | LOWER('HELLO,MYSQL') |
  +----------------------+
  | hello,mysql          |
  +----------------------+
  1 row in set (0.00 sec)
  
  mysql> SELECT UPPER('hello,mysql');
  +----------------------+
  | UPPER('hello,mysql') |
  +----------------------+
  | HELLO,MYSQL          |
  +----------------------+
  1 row in set (0.00 sec)
  ```

- LAPD & RPAD

  ```sql
  mysql> SELECT LPAD('hello,mysql',15,'>');
  +----------------------------+
  | LPAD('hello,mysql',15,'>') |
  +----------------------------+
  | >>>>hello,mysql            |
  +----------------------------+
  1 row in set (0.00 sec)
  
  mysql> SELECT RPAD('hello,mysql',15,'!');
  +----------------------------+
  | RPAD('hello,mysql',15,'!') |
  +----------------------------+
  | hello,mysql!!!!            |
  +----------------------------+
  1 row in set (0.00 sec)
  ```

- TRIM

  ```SQL
  mysql> SELECT TRIM('   Hello  MySQL   ');
  +----------------------------+
  | TRIM('   Hello  MySQL   ') |
  +----------------------------+
  | Hello  MySQL               |
  +----------------------------+
  1 row in set (0.00 sec)
  ```

- SUBSTRING

  ```sql
  mysql> SELECT SUBSTRING('Hello Hud!',7,3);
  +-----------------------------+
  | SUBSTRING('Hello Hud!',7,3) |
  +-----------------------------+
  | Hud                         |
  +-----------------------------+
  1 row in set (0.00 sec)
  
  #这里注意索引值是从1开始的
  ```

**实战演示：由于业务变更，企业员工的工号统一为5位数，不足5位的在前面补0：**

```sql
mysql> UPDATE EMP SET WORKNUM = LPAD(WORKNUM,5,'0');
Query OK, 13 rows affected (0.01 sec)
Rows matched: 13  Changed: 13  Warnings: 0

mysql> SELECT * FROM EMP;
+------+---------+----------+--------+------+--------------------+-------------+------------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  |
+------+---------+----------+--------+------+--------------------+-------------+------------+
|    1 | 00001   | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |
|    2 | 00002   | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |
|    3 | 00003   | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |
|    4 | 00004   | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |
|    5 | 00005   | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |
|    6 | 00006   | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |
|    7 | 00007   | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |
|    8 | 00008   | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |
|    9 | 00009   | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |
|   10 | 00010   | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |
|   11 | 00011   | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |
|   12 | 00012   | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |
|   13 | 00013   | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |
+------+---------+----------+--------+------+--------------------+-------------+------------+
13 rows in set (0.00 sec)
```



#### 1.3.2 数值函数

常见的数值函数

|    函数    |                功能                |
| :--------: | :--------------------------------: |
|  CEIL(x)   |              向上取整              |
|   FLOOR    |              向下取整              |
|  MOD(x,y)  |            返回x/y的模             |
|   RAND()   |         返回0~1内的随机数          |
| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |

**实例演示**

- CEIL & FLOOR

  ```SQL
  mysql> SELECT CEIL(1.7);
  +-----------+
  | CEIL(1.7) |
  +-----------+
  |         2 |
  +-----------+
  1 row in set (0.00 sec)
  
  mysql> SELECT FLOOR(1.7);
  +------------+
  | FLOOR(1.7) |
  +------------+
  |          1 |
  +------------+
  1 row in set (0.00 sec)
  ```

- MOD(求模)

  ```sql
  mysql> SELECT MOD(10,7);
  +-----------+
  | MOD(10,7) |
  +-----------+
  |         3 |
  +-----------+
  1 row in set (0.00 sec)
  ```

- RAND & ROUND

  ```SQL
  mysql> SELECT RAND();
  +---------------------+
  | RAND()              |
  +---------------------+
  | 0.17815020324490052 |
  +---------------------+
  1 row in set (0.00 sec)
  
  mysql> SELECT ROUND(3.1415926,4);
  +--------------------+
  | ROUND(3.1415926,4) |
  +--------------------+
  |             3.1416 |
  +--------------------+
  1 row in set (0.00 sec)
  ```

**案例实战：通过数据库的函数，生成一个六位数的随机验证码**

1. **方法一**：**SELECT SUBSTRING(RAND(),3,6);**

   ```SQL
   mysql> SELECT SUBSTRING(RAND(),3,6);
   +-----------------------+
   | SUBSTRING(RAND(),3,6) |
   +-----------------------+
   | 036733                |
   +-----------------------+
   1 row in set (0.00 sec)
   
   mysql> SELECT SUBSTRING(RAND(),3,6);
   +-----------------------+
   | SUBSTRING(RAND(),3,6) |
   +-----------------------+
   | 440956                |
   +-----------------------+
   1 row in set (0.00 sec)
   ```

 2. **方法二：SELECT ROUND(RAND()*1000000,0);**

    ```SQL
    mysql> SELECT ROUND(RAND()*1000000,0);
    +-------------------------+
    | ROUND(RAND()*1000000,0) |
    +-------------------------+
    |                  466478 |
    +-------------------------+
    1 row in set (0.00 sec)
    
    mysql> SELECT ROUND(RAND()*1000000,0);
    +-------------------------+
    | ROUND(RAND()*1000000,0) |
    +-------------------------+
    |                  882253 |
    +-------------------------+
    1 row in set (0.00 sec)
    ```

    

#### 1.3.3 日期函数

常见的日期函数：

|               函数                |                       功能                        |
| :-------------------------------: | :-----------------------------------------------: |
|             CURDATE()             |                   返回当前日期                    |
|             CURTIME()             |                   返回当前时间                    |
|               NOW()               |                返回当前日期和时间                 |
|            YEAR(date)             |                返回指定date的年份                 |
|            MONTH(date)            |                返回指定date的月份                 |
|             DAY(date)             |                返回指定date的日期                 |
| DATE_ADD(date,INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
|       DATEDIFF(date1,date2)       |    返回起始时间date1和结束时间date2之间的天数     |

**实例演示：**

- **CURDATE & CURTIME & NOW()**

  ```SQL
  mysql> SELECT CURDATE();
  +------------+
  | CURDATE()  |
  +------------+
  | 2022-08-16 |
  +------------+
  1 row in set (0.02 sec)
  
  mysql> SELECT CURTIME();
  +-----------+
  | CURTIME() |
  +-----------+
  | 16:13:56  |
  +-----------+
  1 row in set (0.00 sec)
  
  mysql> SELECT NOW();
  +---------------------+
  | NOW()               |
  +---------------------+
  | 2022-08-16 16:14:02 |
  +---------------------+
  1 row in set (0.00 sec)
  ```

- YEAR() & MONTH() &DAY()

  ```sql
  mysql> SELECT YEAR(NOW())'年',MONTH(NOW())'月',DAY(NOW())'日';
  +------+------+------+
  | 年   | 月   | 日   |
  +------+------+------+
  | 2022 |    8 |   16 |
  +------+------+------+
  1 row in set (0.00 sec)
  ```

- DATEDIFF(date1,date2) & DATE_ADD(date,INTERVAL expr type)

  ```SQL
  mysql> SELECT DATEDIFF(CURDATE(),'2022-2-19') 'SEX&GQC';
  +---------+
  | SEX&GQC |
  +---------+
  |     178 |
  +---------+
  1 row in set (0.00 sec)
  
  mysql> SELECT DATE_ADD('2021-02-19',INTERVAL 178 DAY) 'TODAY' ;
  +------------+
  | TODAY      |
  +------------+
  | 2021-08-16 |
  +------------+
  1 row in set (0.00 sec)
  
  mysql> SELECT DATE_ADD(CURDATE(),INTERVAL -179 DAY) 'SEXDAY' ;
  +------------+
  | SEXDAY     |
  +------------+
  | 2022-02-1 |
  +------------+
  1 row in set (0.00 sec)
  ```

**案例实战：**

​		查询所有员工的入职天数，并根据入职天数倒序排序

```sql
mysql> SELECT NAME, DATEDIFF(CURDATE(),ENTRYDATE) '入职天数' FROM emp ORDER BY DATEDIFF(CURDATE(),ENTRYDATE) DESC;
+----------+----------+
| NAME     | 入职天数 |
+----------+----------+
| 隆多     |    17887 |
| 罗斯     |    15808 |
| 欧文     |    11931 |
| 齐天宇   |     8837 |
| 詹姆斯   |     8698 |
| 柳岩     |     8263 |
| 顾清池   |     8108 |
| 迪丽热巴 |     5184 |
| 杜兰特   |     4808 |
| 威少     |     4547 |
| 郭晶晶   |     4097 |
| 斯嘉丽   |     3879 |
| 张无忌   |     1038 |
+----------+----------+
13 rows in set (0.00 sec)
```

**將入职天数添加到表中**

```sql
mysql> ALTER TABLE emp ADD EDAYS INT;
Query OK, 0 rows affected (0.05 sec)

mysql> SELECT * FROM EMP;
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  | EDAYS |
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
|    1 | 00001   | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |  NULL |
|    2 | 00002   | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |  NULL |
|    3 | 00003   | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |  NULL |
|    4 | 00004   | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |  NULL |
|    5 | 00005   | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |  NULL |
|    6 | 00006   | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |  NULL |
|    7 | 00007   | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |  NULL |
|    8 | 00008   | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |  NULL |
|    9 | 00009   | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |  NULL |
|   10 | 00010   | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |  NULL |
|   11 | 00011   | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |  NULL |
|   12 | 00012   | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |  NULL |
|   13 | 00013   | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |  NULL |
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
13 rows in set (0.00 sec)

mysql> UPDATE emp SET EDAYS = EDAYS + DATEDIFF(CURDATE(),ENTRYDATE);
Query OK, 0 rows affected (0.00 sec)
Rows matched: 13  Changed: 0  Warnings: 0

mysql> SELECT * FROM EMP;
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
| id   | worknum | name     | gender | age  | idcard             | workaddress | entrydate  | EDAYS |
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
|    1 | 00001   | 柳岩     | 女     |   20 | 320126977536235489 | 北京        | 2000-01-01 |  NULL |
|    2 | 00002   | 张无忌   | 男     |   18 | 336978544123659852 | 北京        | 2019-10-13 |  NULL |
|    3 | 00003   | 詹姆斯   | 男     |   37 | 336978544123659852 | 洛城        | 1998-10-23 |  NULL |
|    4 | 00004   | 杜兰特   | 男     |   35 | 336978544123659852 | 纽约        | 2009-06-17 |  NULL |
|    5 | 00005   | 斯嘉丽   | 女     |   26 | 336978544123659852 | 美国        | 2012-01-02 |  NULL |
|    6 | 00006   | 顾清池   | 女     |   22 | 320922200006042366 | 北京        | 2000-06-04 |  NULL |
|    7 | 00007   | 齐天宇   | 男     |   24 | 320102199806062918 | 北京        | 1998-06-06 |  NULL |
|    8 | 00008   | 罗斯     | 男     |   30 | 320102119730312918 | 芝加哥      | 1979-05-06 |  NULL |
|    9 | 00009   | 隆多     | 男     |   32 | 320102196902052918 | 波士顿      | 1973-08-26 |  NULL |
|   10 | 00010   | 迪丽热巴 | 女     |   24 | 320102200103262918 | 新疆        | 2008-06-06 |  NULL |
|   11 | 00011   | 欧文     | 男     |   31 | 320187199806222934 | 纽约        | 1989-12-16 |  NULL |
|   12 | 00012   | 郭晶晶   | 女     |   34 | 320102188625463216 | 北京        | 2011-05-29 |  NULL |
|   13 | 00013   | 威少     | 男     |   19 | NULL               | 俄亥俄      | 2010-03-05 |  NULL |
+------+---------+----------+--------+------+--------------------+-------------+------------+-------+
13 rows in set (0.00 sec)
```

#### 1.3.4 流程控制函数

实现条件筛选，从而提高语句效率

|                           函数                            |                          功能                           |
| :-------------------------------------------------------: | :-----------------------------------------------------: |
|                       IF(value,t,f)                       |           如果value为true，则返回t，否则返回f           |
|                   IFNULL(value1,value2)                   |         如果value不为空返回value1否则返回value2         |
|     CASE WHEN[val1] THEN [res1]...ELSE [default] END      |    如果val1为true,返回res1,...否则返回default默认值     |
| CASE [expr] WHEN [val] THEN [res1] ... ELSE [default] END | 如果expr的值等于val1，返回res1,...否则返回default默认值 |

**案例测试**

- IF

  ```SQL
  mysql> SELECT IF(TRUE,'OK','ERR');
  +---------------------+
  | IF(TRUE,'OK','ERR') |
  +---------------------+
  | OK                  |
  +---------------------+
  1 row in set (0.00 sec)
  ```

- IFNULL

  ```SQL
  mysql> SELECT IFNULL('A','EMPTY');
  +---------------------+
  | IFNULL('A','EMPTY') |
  +---------------------+
  | A                   |
  +---------------------+
  1 row in set (0.00 sec)
  
  mysql> SELECT IFNULL(NULL,'EMPTY');
  +----------------------+
  | IFNULL(NULL,'EMPTY') |
  +----------------------+
  | EMPTY                |
  +----------------------+
  1 row in set (0.00 sec)
  ```

- 查詢emp表中的员工姓名和工作地址，如果工作地址为北京/纽约 ---> 一线城市，其他 ---> 二线城市

  ```SQL
  mysql> SELECT
      -> NAME,
      -> (CASE WORKADDRESS WHEN '北京' THEN '一线城市' WHEN '纽约'THEN '一线城市' ELSE '二线城市' END ) '工作地址'
      -> FROM EMP;
  +----------+----------+
  | NAME     | 工作地址 |
  +----------+----------+
  | 柳岩     | 一线城市 |
  | 张无忌   | 一线城市 |
  | 詹姆斯   | 二线城市 |
  | 杜兰特   | 一线城市 |
  | 斯嘉丽   | 二线城市 |
  | 顾清池   | 一线城市 |
  | 齐天宇   | 一线城市 |
  | 罗斯     | 二线城市 |
  | 隆多     | 二线城市 |
  | 迪丽热巴 | 二线城市 |
  | 欧文     | 一线城市 |
  | 郭晶晶   | 一线城市 |
  | 威少     | 二线城市 |
  +----------+----------+
  13 rows in set (0.00 sec)
  ```

- **案例实操：**

  **统计班级各个学员的成绩，展示的规则如下：**
  **-- >= 85，展示优秀**
  **-- >= 60，展示及格**
  **-- 否则，展示不及格**

```SQL
mysql> SELECT * FROM SCORE;
+------+------+------+---------+---------+
| id   | name | math | english | chinese |
+------+------+------+---------+---------+
|    1 | Tom  |   67 |      88 |      95 |
|    2 | Rose |   23 |      66 |      90 |
|    3 | Jack |   56 |      98 |      76 |
+------+------+------+---------+---------+
3 rows in set (0.00 sec)

mysql> SELECT
    -> ID,
    -> NAME,
    -> (CASE WHEN MATH >= 85 THEN '优秀'WHEN MATH>=60 THEN '及格' ELSE '不及格' END)'数学',
    -> (CASE WHEN ENGLISH >= 85 THEN '优秀'WHEN ENGLISH>=60 THEN '及格' ELSE '不及格' END) '英语',
    -> (CASE WHEN CHINESE >= 85 THEN '优秀'WHEN CHINESE>=60 THEN '及格' ELSE '不及格' END) '语文'
    -> FROM SCORE;
+------+------+--------+------+------+
| ID   | NAME | 数学   | 英语 | 语文 |
+------+------+--------+------+------+
|    1 | Tom  | 及格   | 优秀 | 优秀 |
|    2 | Rose | 不及格 | 及格 | 优秀 |
|    3 | Jack | 不及格 | 优秀 | 及格 |
+------+------+--------+------+------+
3 rows in set (0.00 sec)
```

### 1.4 约束

**概念**：约束是作用于表中字段上的规则，用于限制存储在表中的数据。 

**目的**：保证数据库中数据的正确、有效性和完整性。

<img src="C:\Users\Hud\AppData\Roaming\Typora\typora-user-images\image-20220817190438247.png" alt="image-20220817190438247"  />

**约束演示** 

​		上面我们介绍了数据库中常见的约束，以及约束涉及到的关键字，那这些约束我们到底如何在创建表、 修改表的时候来指定呢，接下来我们就通过一个案例，来演示一下。 

​		案例需求： 根据需求，完成表结构的创建。需求如下：

![image-20220817190635758](C:\Users\Hud\AppData\Roaming\Typora\typora-user-images\image-20220817190635758.png)

**建表，建立数据**

```sql
CREATE TABLE tb_user(
	id int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',
	name varchar(10) NOT NULL UNIQUE COMMENT '姓名' ,
	age int check (age > 0 && age <= 120) COMMENT '年龄' ,
	status char(1) default '1' COMMENT '状态',
	gender char(1) COMMENT '性别'
);

insert into tb_user(name,age,status,gender) values ('Tom1',19,'1','男'),
('Tom2',25,'0','男');
insert into tb_user(name,age,status,gender) values ('Tom3',19,'1','男');
insert into tb_user(name,age,status,gender) values (null,19,'1','男');
insert into tb_user(name,age,status,gender) values ('Tom3',19,'1','男');
insert into tb_user(name,age,status,gender) values ('Tom4',80,'1','男');
insert into tb_user(name,age,status,gender) values ('Tom5',-1,'1','男');
insert into tb_user(name,age,status,gender) values ('Tom5',121,'1','男');
insert into tb_user(name,age,gender) values ('Tom5',120,'男');

```

#### **外键约束**

​		**用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。**

```sql
create table dept(
                     id   int auto_increment comment 'ID' primary key,
                     name varchar(50) not null comment '部门名称'
)comment '部门表';

create table emp(
                    id  int auto_increment comment 'ID' primary key,
                    name varchar(50) not null comment '姓名',
                    age  int comment '年龄',
                    job varchar(20) comment '职位',
                    salary int comment '薪资',
                    entrydate date comment '入职时间',
                    managerid int comment '直属领导ID',
                    dept_id int comment '部门ID'
)comment '员工表';


INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部'),(7,'董事会');
INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES
                   (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
                   (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
                   (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
                   (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
                   (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
                   (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),
                   (8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),
                   (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),
                   (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),
                   (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),
                   (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),
                   (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),
                   (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),
                   (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),
                   (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),
                   (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null),
                   (18, '齐天宇', 24, '董事长',80000, '1998-06-06', 7,7) ;

ALTER TABLE EMP ADD CONSTRAINT FK_EMO_DEPT_ID FOREIGN KEY (dept_id) REFERENCES dept(ID);
```

删除之后董事会之后：

```
mysql> SELECT * FROM EMP;
+----+--------+------+--------------+--------+------------+-----------+---------+
| id | name   | age  | job          | salary | entrydate  | managerid | dept_id |
+----+--------+------+--------------+--------+------------+-----------+---------+
|  1 | 金庸   |   66 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |
|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |
|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |
|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |
|  8 | 周芷若 |   19 | 会计         |  48000 | 2006-06-02 |         7 |       3 |
|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |
| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |
| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |
| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |
| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |
| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |
| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
| 17 | 陈友谅 |   42 | NULL         |   2000 | 2011-10-12 |         1 |    NULL |
| 18 | 齐天宇 |   24 | 董事长       |  80000 | 1998-06-06 |         7 |    NULL |
+----+--------+------+--------------+--------+------------+-----------+---------+
17 rows in set (0.00 sec)
```

**被置为null**

![image-20220817191516092](C:\Users\Hud\AppData\Roaming\Typora\typora-user-images\image-20220817191516092.png)

### 1.5 多表查询

​		项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：

1. **一对多(多对一)** 
2. **多对多(例如学生与课程)**
3.  **一对一**

#### **多对多案例演示：**

```SQL
# 创建学生表
CREATE TABLE STUDENT(
    ID INT AUTO_INCREMENT PRIMARY KEY COMMENT '主键id',
    NAME VARCHAR(10) COMMENT '姓名',
    NO VARCHAR(10) COMMENT '学号'
)COMMENT '学生表';


#添加学生表数据
INSERT INTO STUDENT
VALUES (NULL,'齐天宇','20001001'),(NULL,'顾清池','20001002'),(NULL,'丘比特','20001003'),
       (NULL,'詹姆斯','20001004'),(NULL,'杜兰特','20001005'),(NULL,'罗斯','20001006'),
       (NULL,'莫兰特','20001007');


#创建课程表
CREATE TABLE COURSE(
    ID INT AUTO_INCREMENT PRIMARY KEY COMMENT '主键id',
    NAME VARCHAR(10) COMMENT '课程名称'
)COMMENT '课程表';


#添加课程数据
INSERT INTO COURSE VALUES (NULL,'Golang'),(NULL,'MySQL'),(NULL,'TCP/IP'),(NULL,'OS');

#创建中间表
CREATE TABLE STUDENT_COURSE(
    ID INT AUTO_INCREMENT COMMENT '主键' PRIMARY KEY ,
    STUDENTID INT NOT NULL COMMENT '学生id',
    COURSEID INT NOT NULL COMMENT  '课程id' ,
    CONSTRAINT FK_STUDENTID FOREIGN KEY  (STUDENTID) REFERENCES STUDENT (ID),
    CONSTRAINT FK_COURSEID FOREIGN KEY (COURSEID) REFERENCES COURSE (ID)
)COMMENT '学生中间表';

# 添加中间表数据
INSERT INTO STUDENT_COURSE VALUES (NULL,1,1),(Null,1,2),(Null,1,3),(Null,1,4),(Null,2,2),(Null,2,4),(Null,3,1),(Null,4,2),
                                  (Null,5,1),(Null,5,3),(Null,6,4),(Null,7,2);
```

查看一下三张表

```sql
mysql> SELECT * FROM STUDENT;
+----+--------+----------+
| ID | NAME   | NO       |
+----+--------+----------+
|  1 | 齐天宇 | 20001001 |
|  2 | 顾清池 | 20001002 |
|  3 | 丘比特 | 20001003 |
|  4 | 詹姆斯 | 20001004 |
|  5 | 杜兰特 | 20001005 |
|  6 | 罗斯   | 20001006 |
|  7 | 莫兰特 | 20001007 |
+----+--------+----------+
7 rows in set (0.00 sec)

mysql> SELECT * FROM COURSE;
+----+--------+
| ID | NAME   |
+----+--------+
|  1 | Golang |
|  2 | MySQL  |
|  3 | TCP/IP |
|  4 | OS     |
+----+--------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM STUDENT_COURSE;
+----+-----------+----------+
| ID | STUDENTID | COURSEID |
+----+-----------+----------+
|  1 |         1 |        1 |
|  2 |         1 |        2 |
|  3 |         1 |        3 |
|  4 |         1 |        4 |
|  5 |         2 |        2 |
|  6 |         2 |        4 |
|  7 |         3 |        1 |
|  8 |         4 |        2 |
|  9 |         5 |        1 |
| 10 |         5 |        3 |
| 11 |         6 |        4 |
| 12 |         7 |        2 |
+----+-----------+----------+
12 rows in set (0.00 sec)
```

**关系示意图**：

<img src="C:\Users\Hud\AppData\Roaming\Typora\typora-user-images\image-20220817201618127.png" alt="image-20220817201618127"  />

```SQL

# 基本信息表
create table tb_user(
    ID int auto_increment primary key comment'主键ID',
    NAME varchar(10) comment'姓名',
    age int comment'年龄',
    GENDER CHAR(1) comment'1：男，2：女',
    phone char(11) comment'手机号'
)comment'用户基本信息表:'

#添加数据
create table tb_user_edu(
    id            int auto_increment primary key comment '主键ID',
    degree        varchar(20) comment '学历',
    major         varchar(50) comment '专业',
    primaryschool varchar(50) comment '小学',
    middleschool  varchar(50) comment '中学',
    university    varchar(50) comment '大学',
    userid        int unique comment '用户ID',
    constraint fk_userid foreign key (userid) references tb_user (ID)
)comment'用户教育信息表';

insert into tb_user(ID, NAME, age, GENDER, phone) values
            (NULL,'黄渤',45,1,'18800001111'),
            (NULL,'冰冰',35,2,'18800002222'),
            (NULL,'码云',55,'1','18800008888'),
            (NULL,'李彦宏',50,1,'18800009999');

insert into tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid) values
    (NULL,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
    (NULL,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
    (NULL,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
    (NULL,'本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);
```



#### 多表查询

**概述：指从多张表中查询数据**

**创建数据**

```sql
# 部门表
create table dept(
                     id   int auto_increment comment 'ID' primary key,
                     name varchar(50) not null comment '部门名称'
)comment '部门表';
INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部');


# 创建员工表
create table emp(
                    id  int auto_increment comment 'ID' primary key,
                    name varchar(50) not null comment '姓名',
                    age  int comment '年龄',
                    job varchar(20) comment '职位',
                    salary int comment '薪资',
                    entrydate date comment '入职时间',
                    managerid int comment '直属领导ID',
                    dept_id int comment '部门ID'
)comment '员工表';
INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES
            (1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
            (2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),
            (3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),
            (4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
            (5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),
            (6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),
            (7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),
            (8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),
            (9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),
            (10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),
            (11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),
            (12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),
            (13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),
            (14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),
            (15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),
            (16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),
            (17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);

#添加外键
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);

mysql> SELECT * FROM DEPT;
+----+--------+
| id | name   |
+----+--------+
|  1 | 研发部 |
|  2 | 市场部 |
|  3 | 财务部 |
|  4 | 销售部 |
|  5 | 总经办 |
|  6 | 人事部 |
+----+--------+
6 rows in set (0.00 sec)

mysql> SELECT * FROM EMP;
+----+--------+------+--------------+--------+------------+-----------+---------+
| id | name   | age  | job          | salary | entrydate  | managerid | dept_id |
+----+--------+------+--------------+--------+------------+-----------+---------+
|  1 | 金庸   |   66 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |
|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |
|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |
|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |
|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |
|  8 | 周芷若 |   19 | 会计         |  48000 | 2006-06-02 |         7 |       3 |
|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |
| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |
| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |
| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |
| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |
| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |
| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
| 17 | 陈友谅 |   42 | NULL         |   2000 | 2011-10-12 |         1 |    NULL |
+----+--------+------+--------------+--------+------------+-----------+---------+
17 rows in set (0.00 sec)
```

**多表查询-笛卡尔积**

笛卡尔积指的是在数学中，两个集合，集合A和集合B所有的组合情况（在多表查询时，**需要消除无效的笛卡尔积**）

```sql
# 如果使用
SELECT * FROM EMP,DEPT;
# 会出现很多重复笛卡尔积
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | id | name   |
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  6 | 人事部 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  5 | 总经办 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  4 | 销售部 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  3 | 财务部 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  2 | 市场部 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  1 | 研发部 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  6 | 人事部 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  5 | 总经办 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  4 | 销售部 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  3 | 财务部 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  2 | 市场部 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  1 | 研发部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  6 | 人事部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  5 | 总经办 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  4 | 销售部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  3 | 财务部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  2 | 市场部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  1 | 研发部 |
...# 一共有 6 × 17 = 102 条数据
```

所以要选择外键对应的数据：EMP.dept_id  <---> DEPT.id

```SQL
mysql> SELECT * FROM EMP,DEPT WHERE EMP.DEPT_ID = DEPT.ID ORDER BY EMP.ID;
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | id | name   |
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  5 | 总经办 |
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  1 | 研发部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  1 | 研发部 |
|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |  1 | 研发部 |
|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |  1 | 研发部 |
|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |  1 | 研发部 |
|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |  3 | 财务部 |
|  8 | 周芷若 |   19 | 会计         |  48000 | 2006-06-02 |         7 |       3 |  3 | 财务部 |
|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |  3 | 财务部 |
| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |  2 | 市场部 |
| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |  2 | 市场部 |
| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |  2 | 市场部 |
| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |  2 | 市场部 |
| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |  4 | 销售部 |
| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |  4 | 销售部 |
| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |  4 | 销售部 |
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
16 rows in set (0.00 sec)

#按部门排序
mysql> SELECT * FROM EMP,DEPT WHERE EMP.DEPT_ID = DEPT.ID ORDER BY DEPT.ID;
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
| id | name   | age  | job          | salary | entrydate  | managerid | dept_id | id | name   |
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
|  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |  1 | 研发部 |
|  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |  1 | 研发部 |
|  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |  1 | 研发部 |
|  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |  1 | 研发部 |
|  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |  1 | 研发部 |
| 10 | 赵敏   |   20 | 市场部总监   |  12500 | 2004-10-12 |         1 |       2 |  2 | 市场部 |
| 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |  2 | 市场部 |
| 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |  2 | 市场部 |
| 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |  2 | 市场部 |
|  7 | 灭绝   |   60 | 财务总监     |   8500 | 2002-09-12 |         1 |       3 |  3 | 财务部 |
|  8 | 周芷若 |   19 | 会计         |  48000 | 2006-06-02 |         7 |       3 |  3 | 财务部 |
|  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |  3 | 财务部 |
| 14 | 张三丰 |   88 | 销售总监     |  14000 | 2004-10-12 |         1 |       4 |  4 | 销售部 |
| 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |  4 | 销售部 |
| 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |  4 | 销售部 |
|  1 | 齐天宇 |   24 | 总裁         |  20000 | 2000-01-01 |      NULL |       5 |  5 | 总经办 |
+----+--------+------+--------------+--------+------------+-----------+---------+----+--------+
16 rows in set (0.00 sec)
```

**多表查询的分类：**

- 连接查询：
  - 内连接：相当于查询A、B的交集部分数据
  - 外连接：
    - 左外连接：查询左表所有数据，以及两张表交集部分的数据
    - 右外连接：查询右表所有数据，以及两张表交集部分的数据
  - 自连接：当前表与自身的连接查询，自连接必须使用表别名

#### 内连接

内连接的语法：（查询两张表交集部分）

- 隐式内连接

  ```sql
  SELECT 字段列表 FROM 表1，表2 WHERE 条件...;
  ```

- 显示内连接

  ```sql
  SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 ...;
  ```

**内连接查询示例**

- 查询每一个员工的姓名，以及关联的部门的名称（隐式内连接）

```sql
mysql> SELECT EMP.ID ,EMP.NAME'员工姓名' , DEPT.NAME ‘所在部门’ FROM EMP,DEPT where  EMP.dept_id = DEPT.id ORDER BY emp.id;
+----+----------+------------+
| ID | 员工姓名 | ‘所在部门’    |
+----+----------+------------+
|  1 | 齐天宇   | 总经办       |
|  2 | 张无忌   | 研发部       |
|  3 | 杨逍     | 研发部       |
|  4 | 韦一笑   | 研发部       |
|  5 | 常遇春   | 研发部       |
|  6 | 小昭     | 研发部       |
|  7 | 灭绝     | 财务部       |
|  8 | 周芷若   | 财务部       |
|  9 | 丁敏君   | 财务部       |
| 10 | 赵敏     | 市场部       |
| 11 | 鹿杖客   | 市场部       |
| 12 | 鹤笔翁   | 市场部       |
| 13 | 方东白   | 市场部       |
| 14 | 张三丰   | 销售部       |
| 15 | 俞莲舟   | 销售部       |
| 16 | 宋远桥   | 销售部       |
+----+----------+--------------+
16 rows in set (0.00 sec)
```

**提示：**

​		在遇到表名比较长的情况下的时候，我们可以给表起一个别名 ，语法：

```sql
SELECT E.ID , E.NAME'员工姓名' , D.NAME ‘所在部门’ FROM EMP E ,DEPT D where  E.dept_id = D.id ORDER BY E.id;
```

**注意：一旦起了别名之后，只能使用别名限定字段（因为先执行FROM）不能使用表名了**

- 查询每一个员工的姓名，以及关联的部门的名称（显式内连接）

```SQL
mysql> SELECT EMP.NAME'员工姓名' , DEPT.NAME ‘所在部门’ FROM EMP INNER JOIN DEPT  on emp.dept_id = DEPT.id;
+----------+--------------+
| 员工姓名 | ‘所在部门’ |
+----------+--------------+
| 张无忌   | 研发部       |
| 杨逍     | 研发部       |
| 韦一笑   | 研发部       |
| 常遇春   | 研发部       |
| 小昭     | 研发部       |
| 赵敏     | 市场部       |
| 鹿杖客   | 市场部       |
| 鹤笔翁   | 市场部       |
| 方东白   | 市场部       |
| 灭绝     | 财务部       |
| 周芷若   | 财务部       |
| 丁敏君   | 财务部       |
| 张三丰   | 销售部       |
| 俞莲舟   | 销售部       |
| 宋远桥   | 销售部       |
| 齐天宇   | 总经办       |
+----------+--------------+
16 rows in set (0.00 sec)
```



#### 外连接

- **左外连接**

  ```sql
  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 
  ```

  ```SQL
  # 查詢emp表中的所有数据，以及关联的部门名称（17条数据）
  mysql> SELECT EMP.ID, EMP.NAME,DEPT.NAME FROM EMP LEFT  JOIN DEPT  on EMP.dept_id = DEPT.id  ;
  +----+--------+--------+
  | ID | NAME   | NAME   |
  +----+--------+--------+
  |  1 | 齐天宇 | 总经办 |
  |  2 | 张无忌 | 研发部 |
  |  3 | 杨逍   | 研发部 |
  |  4 | 韦一笑 | 研发部 |
  |  5 | 常遇春 | 研发部 |
  |  6 | 小昭   | 研发部 |
  |  7 | 灭绝   | 财务部 |
  |  8 | 周芷若 | 财务部 |
  |  9 | 丁敏君 | 财务部 |
  | 10 | 赵敏   | 市场部 |
  | 11 | 鹿杖客 | 市场部 |
  | 12 | 鹤笔翁 | 市场部 |
  | 13 | 方东白 | 市场部 |
  | 14 | 张三丰 | 销售部 |
  | 15 | 俞莲舟 | 销售部 |
  | 16 | 宋远桥 | 销售部 |
  | 17 | 陈友谅 | NULL   |
  +----+--------+--------+
  17 rows in set (0.00 sec)
  ```

  

- **右外连接**

  ```sql
  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 
  ```

  ```sql
  # 查詢dept表中的所有数据，以及对应的emp表中的员工信息
  mysql> SELECT DEPT.*, EMP.name FROM EMP RIGHT  JOIN DEPT on DEPT.id = EMP.dept_id  ;
  +----+--------+--------+
  | id | name   | name   |
  +----+--------+--------+
  |  1 | 研发部 | 张无忌 |
  |  1 | 研发部 | 杨逍   |
  |  1 | 研发部 | 韦一笑 |
  |  1 | 研发部 | 常遇春 |
  |  1 | 研发部 | 小昭   |
  |  2 | 市场部 | 赵敏   |
  |  2 | 市场部 | 鹿杖客 |
  |  2 | 市场部 | 鹤笔翁 |
  |  2 | 市场部 | 方东白 |
  |  3 | 财务部 | 灭绝   |
  |  3 | 财务部 | 周芷若 |
  |  3 | 财务部 | 丁敏君 |
  |  4 | 销售部 | 张三丰 |
  |  4 | 销售部 | 俞莲舟 |
  |  4 | 销售部 | 宋远桥 |
  |  5 | 总经办 | 齐天宇 |
  |  6 | 人事部 | NULL   |
  +----+--------+--------+
  ```

  可以看到 人事部虽然没有员工但是也出现在了表中

  

#### 自连接

- **自连接语法**

  ```sql
  SELECT 字典列表 FROM 表A 别名A JOIN 表A 别名B ON 条件;
  ```

  自连接查询，可以是内连接查询，也可以是外连接查询

  

- **自连接示例**    **EMP表中的`managerid`为员工所属领导的id**

  - 查询员工及其所属领导的名字

    ```sql
    mysql> SELECT E1.id, E1.NAME '员工姓名' , E2.NAME '所属领导' FROM EMP E1 JOIN EMP E2 ON E1.managerid=E2.id order by e1.id;
    +----+----------+----------+
    | id | 员工姓名 | 所属领导 |
    +----+----------+----------+
    |  2 | 张无忌   | 齐天宇   |
    |  3 | 杨逍     | 张无忌   |
    |  4 | 韦一笑   | 张无忌   |
    |  5 | 常遇春   | 杨逍     |
    |  6 | 小昭     | 张无忌   |
    |  7 | 灭绝     | 齐天宇   |
    |  8 | 周芷若   | 灭绝     |
    |  9 | 丁敏君   | 灭绝     |
    | 10 | 赵敏     | 齐天宇   |
    | 11 | 鹿杖客   | 赵敏     |
    | 12 | 鹤笔翁   | 赵敏     |
    | 13 | 方东白   | 赵敏     |
    | 14 | 张三丰   | 齐天宇   |
    | 15 | 俞莲舟   | 张三丰   |
    | 16 | 宋远桥   | 张三丰   |
    | 17 | 陈友谅   | 齐天宇   |
    +----+----------+----------+
    16 rows in set (0.00 sec)
    ```

  - 查询所有员工及其领导 即使没有领导也要查询出来（自外连接）

    ```sql
    mysql> SELECT E1.ID,E1.NAME '姓名',E2.NAME '所属领导' FROM EMP E1 LEFT  JOIN EMP E2 on E1.managerid = E2.id  ;
    +----+--------+----------+
    | ID | 姓名   | 所属领导 |
    +----+--------+----------+
    |  1 | 齐天宇 | NULL     |
    |  2 | 张无忌 | 齐天宇   |
    |  3 | 杨逍   | 张无忌   |
    |  4 | 韦一笑 | 张无忌   |
    |  5 | 常遇春 | 杨逍     |
    |  6 | 小昭   | 张无忌   |
    |  7 | 灭绝   | 齐天宇   |
    |  8 | 周芷若 | 灭绝     |
    |  9 | 丁敏君 | 灭绝     |
    | 10 | 赵敏   | 齐天宇   |
    | 11 | 鹿杖客 | 赵敏     |
    | 12 | 鹤笔翁 | 赵敏     |
    | 13 | 方东白 | 赵敏     |
    | 14 | 张三丰 | 齐天宇   |
    | 15 | 俞莲舟 | 张三丰   |
    | 16 | 宋远桥 | 张三丰   |
    | 17 | 陈友谅 | 齐天宇   |
    +----+--------+----------+
    ```



#### 联合查询

**概念**

​		所谓联合查询就是：把多次查询的结果联合起来，形成一个新的查询结果集

**注意**

​		联合查询的两张表的查询结果返回字段数需要一直，不然会报错无法合并

```SQL
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B ...
```

**案例演示**

- 将薪水低于5000的员工**和**年龄大于50的员工全部罗列出来 (**注意是和不是且**)

  ```sql
  mysql> SELECT * FROM EMP WHERE salary<5000
      -> UNION
      -> SELECT * FROM emp WHERE AGE>50 ORDER BY ID;
  +----+--------+------+----------+--------+------------+-----------+---------+
  | id | name   | age  | job      | salary | entrydate  | managerid | dept_id |
  +----+--------+------+----------+--------+------------+-----------+---------+
  |  7 | 灭绝   |   60 | 财务总监 |   8500 | 2002-09-12 |         1 |       3 |
  | 11 | 鹿杖客 |   56 | 职员     |   3750 | 2006-10-03 |        10 |       2 |
  | 12 | 鹤笔翁 |   19 | 职员     |   3750 | 2007-05-09 |        10 |       2 |
  | 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 |
  | 15 | 俞莲舟 |   38 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
  | 16 | 宋远桥 |   40 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
  | 17 | 陈友谅 |   42 | NULL     |   2000 | 2011-10-12 |         1 |    NULL |
  +----+--------+------+----------+--------+------------+-----------+---------+
  7 rows in set (0.00 sec
  ```

  如果使用UNION ALL 就是将两张表合并在一起（有重复数据了11鹿杖客）

  ```sql
  mysql> SELECT * FROM EMP WHERE salary<5000
      -> UNION ALL
      -> SELECT * FROM emp WHERE AGE>50 ORDER BY ID;
  +----+--------+------+----------+--------+------------+-----------+---------+
  | id | name   | age  | job      | salary | entrydate  | managerid | dept_id |
  +----+--------+------+----------+--------+------------+-----------+---------+
  |  7 | 灭绝   |   60 | 财务总监 |   8500 | 2002-09-12 |         1 |       3 |
  | 11 | 鹿杖客 |   56 | 职员     |   3750 | 2006-10-03 |        10 |       2 |
  | 11 | 鹿杖客 |   56 | 职员     |   3750 | 2006-10-03 |        10 |       2 |
  | 12 | 鹤笔翁 |   19 | 职员     |   3750 | 2007-05-09 |        10 |       2 |
  | 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 |
  | 15 | 俞莲舟 |   38 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
  | 16 | 宋远桥 |   40 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
  | 17 | 陈友谅 |   42 | NULL     |   2000 | 2011-10-12 |         1 |    NULL |
  +----+--------+------+----------+--------+------------+-----------+---------+
  8 rows in set (0.00 sec
  ```



#### 子查询

- **概念**

​		SQL语句中嵌套SELECT语句，就称为嵌套查询，又称为子查询

- **语法**	

```SQL
SELECT * FROM T1 WHERE COLUMN1 = (SELECT COLUMN1 FROM T2)
```

**子查询的外部语句可以是`INSERT/UPDATE/DELETE/SELECT`的任何一个**

- **根据子查询结果的不同，可以分为：**

  - 标量子查询()

  - 列子查询(子查询结果为一列)

  - 行子查询(子查询结果为一行)

  - 表子查询(子查询结果为多行多列)

- **根据子查询位置分为：**
  - WHERE之后
  - FROM之后
  - SELECT之后

##### 1.标量子查询

​		子查询的结果为单个值(数字，字符串，日期等)，最简单的形式

​		常用操作符：**= / <> / > / >= / < / <=**

**案例演示**

- 查询“销售部”所有员工的信息

  分成两步：

  - 查询销售部部门id(SELECT ID FROM DEPT WHERE NAME = '销售部';)
  - 查询部门id=销售部部门id的员工信息

```sql
mysql> SELECT * FROM EMP WHERE dept_id = (SELECT ID FROM DEPT WHERE NAME = '销售部');
+----+--------+------+----------+--------+------------+-----------+---------+
| id | name   | age  | job      | salary | entrydate  | managerid | dept_id |
+----+--------+------+----------+--------+------------+-----------+---------+
| 14 | 张三丰 |   88 | 销售总监 |  14000 | 2004-10-12 |         1 |       4 |
| 15 | 俞莲舟 |   38 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
| 16 | 宋远桥 |   40 | 销售     |   4600 | 2004-10-12 |        14 |       4 |
+----+--------+------+----------+--------+------------+-----------+---------+
3 rows in set (0.00 sec)
```

- 查询在东方白入职后入职的职工信息

  - 查询东方白入职的时间
  - 查询在上面这个时间之后入职的员工信息

  ```sql
  mysql> SELECT * FROM EMP WHERE entrydate > (SELECT entrydate FROM emp WHERE NAME = '方东白');
  +----+--------+------+------+--------+------------+-----------+---------+
  | id | name   | age  | job  | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------+--------+------------+-----------+---------+
  |  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13   |         7 |       3 |
  | 17 | 陈友谅 |   42 | NULL |   2000 | 2011-10-12  |         1 |    NULL |
  +----+--------+------+------+--------+------------+-----------+---------+
  2 rows in set (0.00 sec)
  ```

#####  2.列子查询

​		子查询返回的结果是一列（可以是多行），这种查询称为列子查询

​		常用的操作符：IN、NOT IN、ANY、SOME、ALL

| 操作符 |                  描述                  |
| :----: | :------------------------------------: |
|   IN   |         在指定的集合内，多选一         |
| NOT IN |          不在指定的集合范围内          |
|  ANY   |  子查询返回列表中，有任意一个满足即可  |
|  SOME  | 与ANY等同，使用SOME的地方都可以使用ANY |
|  ALL   |    子查询返回列表的所有值都必须满足    |

**案例演示**	

- 查询“销售部”和“市场部”的所有员工信息

  ```SQL
  SELECT * FROM EMP WHERE DEPT_ID IN(SELECT ID FROM DEPT WHERE NAME = '销售部' OR NAME ='市场部');
  
  +----+--------+------+------------+--------+------------+-----------+---------+
  | id | name   | age  | job        | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------------+--------+------------+-----------+---------+
  | 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1   |      2   |
  | 11 | 鹿杖客 |   56 | 职员       |   3750 | 2006-10-03 |        10  |      2   |
  | 12 | 鹤笔翁 |   19 | 职员       |   3750 | 2007-05-09 |        10 |       2   |
  | 13 | 方东白 |   19 | 职员       |   5500 | 2009-02-12 |        10 |       2   |
  | 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |        4   |
  | 15 | 俞莲舟 |   38 | 销售       |   4600 | 2004-10-12 |        14 |       4   |
  | 16 | 宋远桥 |   40 | 销售       |   4600 | 2004-10-12 |        14 |       4   |
  +----+--------+------+------------+--------+------------+-----------+---------+
  ```

- 查询比财务部所有人工资都高的员工信息

  ```sql
  SELECT * FROM EMP WHERE SALARY > ALL (SELECT SALARY FROM EMP WHERE DEPT_ID = (SELECT ID FROM DEPT WHERE NAME = '财务部'));
  +----+--------+------+------------+--------+------------+-----------+---------+
  | id | name   | age  | job        | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------------+--------+------------+-----------+---------+
  |  1 | 齐天宇 |   24 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |
  |  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |
  |  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |
  |  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |
  | 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |
  | 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |
  +----+--------+------+------------+--------+------------+-----------+---------+
  6 rows in set (0.00 sec)
  ```

  ALL表示的是子查询所有的结果都必须要满足

  

- 查询比研发部任意一个员工工资都高的员工信息

  ```sql
  SELECT * FROM EMP WHERE SALARY > ANY (SELECT SALARY FROM EMP WHERE DEPT_ID = (SELECT ID FROM DEPT WHERE NAME = '研发部'));
  +----+--------+------+------------+--------+------------+-----------+---------+
  | id | name   | age  | job        | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------------+--------+------------+-----------+---------+
  |  1 | 齐天宇 |   24 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |
  |  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |
  |  3 | 杨逍   |   33 | 开发       |   8400 | 2000-11-03 |         2 |       1 |
  |  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |
  |  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |
  |  7 | 灭绝   |   60 | 财务总监   |   8500 | 2002-09-12 |         1 |       3 |
  | 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |
  | 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |
  +----+--------+------+------------+--------+------------+-----------+---------+
  8 rows in set (0.00 sec)
  ```



##### 3.行子查询

​	行子查询返回的结果是一行（可以是多列），这种子查询称为行子查询

​	常用的操作符：= 、<> 、IN 、NOT IN

**案例演示**

- 查询与“张无忌”的自信及直属领导相同的员工信息

  ```sql
  SELECT * FROM EMP WHERE (SALARY,MANAGERID) = (SELECT SALARY , MANAGERID FROM EMP WHERE NAME = '张无忌') && NAME <> '张无忌';
  +----+------+------+------------+--------+------------+-----------+---------+
  | id | name | age  | job        | salary | entrydate  | managerid | dept_id | 
  +----+------+------+------------+--------+------------+-----------+---------+
  | 10 | 赵敏 |   20 | 市场部总监 |  12500 | 2004-10-12 |            1 |       2 |
  +----+------+------+------------+--------+------------+-----------+---------+
  ```



##### 4.表子查询

​	子查询返回的结果是多行多列，这种子查询称为表子查询

​	常用的操作符： IN

**案例演示**

- 查询与“鹿仗客”，“宋远桥”的职位和资薪相同的员工信息

  ```SQL
  SELECT * FROM EMP WHERE (JOB , SALARY) IN (SELECT JOB,SALARY  FROM EMP WHERE NAME = '鹿杖客' OR NAME = '宋远桥') && NAME NOT IN ('鹿杖客','宋远桥');
  +----+--------+------+------+--------+------------+-----------+---------+
  | id | name   | age  | job  | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------+--------+------------+-----------+---------+
  | 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2 |
  | 15 | 俞莲舟 |   38 | 销售 |   4600 | 2004-10-12 |        14 |       4 |
  +----+--------+------+------+--------+------------+-----------+---------+
  ```

- 查詢入职日期是“2006-01-01”之后的员工信息以及部门信息

  ```SQL
  SELECT E.*,D.*  FROM (SELECT * FROM EMP WHERE ENTRYDATE > '2006-01-01') E LEFT JOIN DEPT D ON E.DEPT_ID = D.ID ;
  
  +----+--------+------+------+--------+------------+-----------+---------+------+--------+
  | id | name   | age  | job  | salary | entrydate  | managerid | dept_id | id   | name   |
  +----+--------+------+------+--------+------------+-----------+---------+------+--------+
  |  8 | 周芷若 |   19 | 会计 |   4800 | 2006-06-02 |         7 |       3  |    3  | 财务部  |
  |  9 | 丁敏君 |   23 | 出纳 |   5250 | 2009-05-13 |         7 |       3  |    3  | 财务部  |
  | 11 | 鹿杖客 |   56 | 职员 |   3750 | 2006-10-03 |        10 |       2  |    2  | 市场部  |
  | 12 | 鹤笔翁 |   19 | 职员 |   3750 | 2007-05-09 |        10 |       2  |    2  | 市场部  |
  | 13 | 方东白 |   19 | 职员 |   5500 | 2009-02-12 |        10 |       2  |    2  | 市场部  |
  | 17 | 陈友谅 |   42 | NULL |   2000 | 2011-10-12 |         1 |    NULL | NULL | NULL   |
  +----+--------+------+------+--------+------------+-----------+---------+------+--------+
  ```




#### 多表查询练习

- 查询员工的姓名、年龄、职位、部门信息(隐式内连接)

  ```sql
  SELECT E.NAME,E.AGE,E.JOB,D.* FROM EMP E,DEPT D WHERE E.DEPT_ID= D.ID;
  +--------+------+--------------+----+--------+
  | NAME   | AGE  | JOB          | id | name   |
  +--------+------+--------------+----+--------+
  | 张无忌 |   20 | 项目经理     |  1 | 研发部 |
  | 杨逍   |   33 | 开发         |  1 | 研发部 |
  | 韦一笑 |   48 | 开发         |  1 | 研发部 |
  | 常遇春 |   43 | 开发         |  1 | 研发部 |
  | 小昭   |   19 | 程序员鼓励师 |  1 | 研发部 |
  | 赵敏   |   20 | 市场部总监   |  2 | 市场部 |
  | 鹿杖客 |   56 | 职员         |  2 | 市场部 |
  | 鹤笔翁 |   19 | 职员         |  2 | 市场部 |
  | 方东白 |   19 | 职员         |  2 | 市场部 |
  | 灭绝   |   60 | 财务总监     |  3 | 财务部 |
  | 周芷若 |   19 | 会计         |  3 | 财务部 |
  | 丁敏君 |   23 | 出纳         |  3 | 财务部 |
  | 张三丰 |   88 | 销售总监     |  4 | 销售部 |
  | 俞莲舟 |   38 | 销售         |  4 | 销售部 |
  | 宋远桥 |   40 | 销售         |  4 | 销售部 |
  | 齐天宇 |   24 | 总裁         |  5 | 总经办 |
  +--------+------+--------------+----+--------+
  ```

- 查询年龄小于30岁的员工姓名、年龄、职位、部门信息(显示内连接)

  ```SQL
  SELECT E.NAME,E.AGE,E.JOB,D.NAME FROM EMP E INNER JOIN DEPT D ON E.dept_id = D.id WHERE E.AGE < 30;
  +--------+------+--------------+--------+
  | NAME   | AGE  | JOB          | NAME   |
  +--------+------+--------------+--------+
  | 齐天宇 |   24 | 总裁         | 总经办 |
  | 张无忌 |   20 | 项目经理     | 研发部 |
  | 小昭   |   19 | 程序员鼓励师 | 研发部 |
  | 周芷若 |   19 | 会计         | 财务部 |
  | 丁敏君 |   23 | 出纳         | 财务部 |
  | 赵敏   |   20 | 市场部总监   | 市场部 |
  | 鹤笔翁 |   19 | 职员         | 市场部 |
  | 方东白 |   19 | 职员         | 市场部 |
  +--------+------+--------------+--------+=
  ```

- 查询拥有员工的部门ID、部门名称

  ```SQL
  SELECT DISTINCT D.ID,D.NAME FROM DEPT D , EMP E WHERE D.ID = E.dept_id;
  +----+--------+
  | ID | NAME   |
  +----+--------+
  |  1 | 研发部 |
  |  2 | 市场部 |
  |  3 | 财务部 |
  |  4 | 销售部 |
  |  5 | 总经办 |
  +----+--------+
  5 rows in set (0.00 sec)
  ```

- 查询所有年龄大于40岁的员工及其归属的部门名称，如果员工没有分配部门也要展示出来

  ```sql
  SELECT E.NAME,D.name FROM EMP E LEFT JOIN dept d on d.id = E.dept_id WHERE E.AGE>40;
  +--------+--------+
  | NAME   | name   |
  +--------+--------+
  | 韦一笑  |  研发部 |
  | 常遇春  |  研发部 |
  | 灭绝    |  财务部 |
  | 鹿杖客  |  市场部 |
  | 张三丰  |  销售部 |
  | 陈友谅  |  NULL  |
  +--------+--------+
  ```

- 查询所有员工的工资等级

  ```sql
  SELECT E.name,S.GRADE FROM EMP E, SALGRADE S WHERE E.salary >= S.losal && E.SALARY <= S.hisal;
  +--------+-------+
  | name   | GRADE |
  +--------+-------+
  | 齐天宇 |     6 |
  | 张无忌 |     5 |
  | 杨逍   |     4 |
  | 韦一笑 |     5 |
  | 常遇春 |     5 |
  | 小昭   |     3 |
  | 灭绝   |     4 |
  | 周芷若 |     2 |
  | 丁敏君 |     3 |
  | 赵敏   |     5 |
  | 鹿杖客 |     2 |
  | 鹤笔翁 |     2 |
  | 方东白 |     3 |
  | 张三丰 |     5 |
  | 俞莲舟 |     2 |
  | 宋远桥 |     2 |
  | 陈友谅 |     1 |
  +--------+-------+
  ```

- 查询“研发部”所有员工的信息及工资等级

  ```SQL
  SELECT E.*,S.grade FROM EMP E,salgrade S WHERE DEPT_ID =(SELECT ID FROM DEPT WHERE NAME='研发部') && E.salary >= S.losal && E.SALARY <= S.hisal;
  +----+--------+------+--------------+--------+------------+-----------+---------+-------+
  | id | name   | age  | job          | salary | entrydate  | managerid | dept_id | grade |
  +----+--------+------+--------------+--------+------------+-----------+---------+-------+
  |  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |     3 |
  |  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |     4 |
  |  5 | 常遇春 |   43 | 开发         |  10500 | 2004-09-07 |         3 |       1 |     5 |
  |  4 | 韦一笑 |   48 | 开发         |  11000 | 2002-02-05 |         2 |       1 |     5 |
  |  2 | 张无忌 |   20 | 项目经理     |  12500 | 2005-12-05 |         1 |       1 |     5 |
  +----+--------+------+--------------+--------+------------+-----------+---------+-------+
  ```

- 查询“研发部”员工的平均工资

  ```SQL
  SELECT AVG(E.salary) FROM EMP E , DEPT D WHERE E.DEPT_ID = (SELECT ID FROM DEPT WHERE NAME='研发部');
  +---------------+
  | AVG(E.salary) |
  +---------------+
  |     9800.0000 |
  +---------------+
  ```

- 查询工资比“灭绝”高的员工信息

  ```SQL
  SELECT * FROM EMP E WHERE E.salary >(SELECT E.salary FROM EMP E WHERE E.NAME = '灭绝');
  +----+--------+------+------------+--------+------------+-----------+---------+
  | id | name   | age  | job        | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------------+--------+------------+-----------+---------+
  |  1 | 齐天宇 |   24 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |
  |  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |
  |  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |
  |  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |
  | 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |
  | 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |
  +----+--------+------+------------+--------+------------+-----------+---------+
  ```

- 查询比平均资薪高的员工信息

  ```SQL
  SELECT * FROM EMP E WHERE E.salary >(SELECT AVG(E.SALARY) FROM EMP E);
  +----+--------+------+------------+--------+------------+-----------+---------+
  | id | name   | age  | job        | salary | entrydate  | managerid | dept_id |
  +----+--------+------+------------+--------+------------+-----------+---------+
  |  1 | 齐天宇 |   24 | 总裁       |  20000 | 2000-01-01 |      NULL |       5 |
  |  2 | 张无忌 |   20 | 项目经理   |  12500 | 2005-12-05 |         1 |       1 |
  |  3 | 杨逍   |   33 | 开发       |   8400 | 2000-11-03 |         2 |       1 |
  |  4 | 韦一笑 |   48 | 开发       |  11000 | 2002-02-05 |         2 |       1 |
  |  5 | 常遇春 |   43 | 开发       |  10500 | 2004-09-07 |         3 |       1 |
  |  7 | 灭绝   |   60 | 财务总监   |   8500 | 2002-09-12 |         1 |       3 |
  | 10 | 赵敏   |   20 | 市场部总监 |  12500 | 2004-10-12 |         1 |       2 |
  | 14 | 张三丰 |   88 | 销售总监   |  14000 | 2004-10-12 |         1 |       4 |
  +----+--------+------+------------+--------+------------+-----------+---------+
  ```

- 查询比本部门平均工资低的员工信息

  ```sql
  SELECT * FROM EMP E1 WHERE E1.salary < (SELECT AVG(E2.salary) FROM EMP E2 WHERE E1.dept_id=E2.dept_id);
  +----+--------+------+--------------+--------+------------+-----------+---------+
  | id | name   | age  | job          | salary | entrydate  | managerid | dept_id |
  +----+--------+------+--------------+--------+------------+-----------+---------+
  |  3 | 杨逍   |   33 | 开发         |   8400 | 2000-11-03 |         2 |       1 |
  |  6 | 小昭   |   19 | 程序员鼓励师 |   6600 | 2004-10-12 |         2 |       1 |
  |  8 | 周芷若 |   19 | 会计         |   4800 | 2006-06-02 |         7 |       3 |
  |  9 | 丁敏君 |   23 | 出纳         |   5250 | 2009-05-13 |         7 |       3 |
  | 11 | 鹿杖客 |   56 | 职员         |   3750 | 2006-10-03 |        10 |       2 |
  | 12 | 鹤笔翁 |   19 | 职员         |   3750 | 2007-05-09 |        10 |       2 |
  | 13 | 方东白 |   19 | 职员         |   5500 | 2009-02-12 |        10 |       2 |
  | 15 | 俞莲舟 |   38 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
  | 16 | 宋远桥 |   40 | 销售         |   4600 | 2004-10-12 |        14 |       4 |
  +----+--------+------+--------------+--------+------------+-----------+---------+
  ```
  
- 查询所有的部门信息，并统计部门的员工人数

  ```sql
  SELECT ID,NAME , (SELECT COUNT(*) FROM EMP E WHERE E.dept_id=D.id) '人数'FROM DEPT D;
  +------+--------+------+
  | ID   | NAME   | 人数 |
  +------+--------+------+
  |    1 | 研发部 |    5 |
  |    2 | 市场部 |    4 |
  |    3 | 财务部 |    3 |
  |    4 | 销售部 |    3 |
  |    5 | 总经办 |    1 |
  |    6 | 人事部 |    0 |
  +------+--------+------+
  ```

- 查询所有学生的选课情况，展示出学生的姓名、学号、课程名称

  ```sql
  # 连接条件
  # STUDENT.ID = STUDENT_COURSE.STUDENTID , COURSE.ID = STUDENT_COURSE.COURSEID
  SELECT S.NAME ,S.NO, C.NAME FROM student S ,course C ,student_course SC WHERE S.ID=SC.STUDENTID && C.ID= SC.COURSEID;
  +--------+----------+--------+
  | NAME   | NO       | NAME   |
  +--------+----------+--------+
  | 齐天宇 | 20001001 | Golang |
  | 丘比特 | 20001003 | Golang |
  | 杜兰特 | 20001005 | Golang |
  | 齐天宇 | 20001001 | MySQL  |
  | 顾清池 | 20001002 | MySQL  |
  | 詹姆斯 | 20001004 | MySQL  |
  | 莫兰特 | 20001007 | MySQL  |
  | 齐天宇 | 20001001 | TCP/IP |
  | 杜兰特 | 20001005 | TCP/IP |
  | 齐天宇 | 20001001 | OS     |
  | 顾清池 | 20001002 | OS     |
  | 罗斯   | 20001006 | OS     |
  ```



### 1.6 事务

- **简介**

​		事务是一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**



#### **事务案例**

- **创建数据**

  ```sql
  create table account(
      id int auto_increment primary key comment '主键ID',
      name varchar(10) comment '姓名',
      money int comment '余额'
  ) comment '账户表';
  insert into account(id, name, money) VALUES (null,'张三',2000),(null,'李四',2000);
  ```

- **转账操作**

  ```sql
  # 查询张三账户余额
  SELECT * FROM ACCOUNT WHERE NAME = '张三';
  # 张三账户余额-1000
  UPDATE ACCOUNT SET MONEY = MONEY - 1000 WHERE NAME = '张三';
  # 李四账户余额+1000
  UPDATE ACCOUNT SET MONEY = MONEY + 1000 WHERE NAME = '李四';
  ```

- **恢复数据**

  ```sql
  update account set money = 2000 where name = '张三' or name = '李四';
  ```



#### 事务操作

- **查看/设置事务提交的方式**

  ```sql
  SELECT @@autocommit		#查看提交方式
  SET @@autocommit=0		#如果为1 是自动提交 如果为0就不是
  ```

- **提交事务**

  ```sql
  COMMIT;
  ```

- **回滚事务**

  ```sql
  ROLLBACK
  ```

**如果SET @@autocommit=0** 那么证明此时不是自动提交 我们在执行完语句之后，还需要手动输入`commit;`指令提交这次操作，对数据库中的数据进行修改。

如果在执行的过程中，发生了报错，那么我们就不要进行`commit`操作，使用`ROLLBACK`进行回滚。

- **开启事务**

  ```SQL
  START TRANSACTION 或 BEGIN
  ```

- **提交事务**

  ```sql
  COMMIT;
  ```

- **回滚事务**

  ```sql
  ROLLBACK;
  ```



**事务的四大特性**

1. **原子性（Atomicity）：**事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
2.  **一致性（Consistency）：**事务完成时，必须使所有的数据都保持一致状态。
3.  **隔离性（Isolation）：**数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。 
4. **持久性（Durability）：**事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 上述就是事务的四大特性，简称ACID。



#### **并发事务问题**

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读到另一个事务还没有提交的数据                       |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读 |
| 幻读       | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入时又发现这行数据已经存在 |

#### **事务的隔离级别**

|         隔离级别          | 脏读 | 不可重复读 | 幻读 |
| :-----------------------: | :--: | :--------: | :--: |
|   **Read uncommitted**    |  √   |     √      |  √   |
|    **Read committed**     |  ×   |     ×      |  √   |
| **Repeatable Read(默认)** |  ×   |     ×      |  √   |
|     **Serializable**      |  ×   |     ×      |  ×   |

**Serializable**的隔离级别最高，但是性能最差

- **查看事务的隔离级别**

  ```sql
   SELECT @@TRANSACTION_ISOLATION;
  ```

- **设置事务的隔离级别**

  ```sql
  SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE }
  ```

**脏读实例**

​		比如同时开两个mysql窗口，在其中一个窗口开始一个事务，还没有确认(COMMIT) ，在另外一个mysql窗口读取数据会发现此时的数据已经被改变了，这就是数据的脏读。

**不可重复读实例**

​		比如同时开两个mysql窗口，在其中一个窗口A开始一个事务，此时在另外一个窗口B读取到数据库中表数据。在窗口A中修改表中数据，提交之后并在窗口B中再次进行读取，会发现数据并未改变。在窗口B中对事务进行提交`COMMIT`，并查询此时数据，发现数据这才发生改变。

**幻读**

​		并发读写情况下，在两个mysql窗口中。我们首先在窗口A对表中数据查询，例如我们查询ID为7的员工数据，发现表中没有ID为7的员工数据。此时窗口B中正在进行数据`INSERT`操作，添加了一个ID为7的员工。窗口A随后向表中添加ID为7的员工数据却报错，原因是表中已经有了ID为7的员工数据。

**Serializable**解决幻读问题：当两个终端对同一张表都开启了一个事务的时候，如果其中一个事务先执行了一个操作，在他进行`COMMIT`之前，另外一个终端对这张表的事务操作会一直阻塞，直到COMMIT。



## 2.  进阶篇

### 2.1 存储引擎

#### MySQL体系结构

- **连接层**

  最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限

- **服务层**

  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询,SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。
  
- **引擎层**

  存储引擎真的的负责了MySQL中的存储和提取，服务器通过API和存储引擎进行通讯，不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。

- **存储层**

  主要是将数据存储在文件系统上，并完成与存储引擎的交互



#### 存储引擎简介

- 查询建表语句

  - SHOW CREATE TABLE 表名;

    ```sql
    CREATE TABLE `emp` (
      `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
      `name` varchar(50) NOT NULL COMMENT '姓名',
      `age` int DEFAULT NULL COMMENT '年龄',
      `job` varchar(20) DEFAULT NULL COMMENT '职位',
      `salary` int DEFAULT NULL COMMENT '薪资',
      `entrydate` date DEFAULT NULL COMMENT '入职时间',
      `managerid` int DEFAULT NULL COMMENT '直属领导ID',
      `dept_id` int DEFAULT NULL COMMENT '部门ID',
      PRIMARY KEY (`id`),
      KEY `fk_emp_dept_id` (`dept_id`),
      CONSTRAINT `fk_emp_dept_id` FOREIGN KEY (`dept_id`) REFERENCES `dept` (`id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='员工表'
    ```

    - 在创建表的时候，指定存储引擎

      ```sql
      engine=INNODB
      ```

  - 查看当前数据

    ```sql
    mysql> show engines;
    +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
    | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
    +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
    | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
    | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
    | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
    | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
    | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
    | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
    | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
    | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
    | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
    +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
    9 rows in set (0.00 sec)
    ```

- 创建表 myisam，指定MyISAM存储引擎

  ```SQL
  CREATE TABLE MY_MYISAM(
      ID INT ,
      NAME VARCHAR(10)
  )ENGINE = MyISAM;
  ```

- 创建表my_memory，指定存储引擎为Memory

  ```SQL
  create table my_myisam
  (    ID   int  ,
      NAME varchar(10) 
  )engine = MyISAM;
  ```

#### 存储引擎特点

##### **InnoDB**

​		InnoDB是一种兼顾高可靠和高性能的通用存储引擎，在MySQL 5.5之后，InnoDB也是默认的MySQL存储引擎

- **特点**
  
  - DML操作遵循ACID模型，支持**事务**
  - **行级锁**，提高并发访问性能
  - 支持**外键**FOREIGN KEY约束，保证数据的完整性和正确性
  
- **文件**
  
  - xxx.ibd：xxx代表的是表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm,sdl）、数据和索引。
  
  - 参数：innodb_file_per_table
  
    ```sql
    #查看系统变量SHOW VARIABLES LIKE
    mysql> SHOW VARIABLES LIKE 'innodb_file_per_table';
    +-----------------------+-------+
    | Variable_name         | Value |
    +-----------------------+-------+
    | innodb_file_per_table | ON    |
    +-----------------------+-------+
    1 row in set, 1 warning (0.01 sec)
    ```
  
    在`C:\ProgramData\MySQL\MySQL Server 8.0\Data\`的目录下存放着表数据
  
    ```bash
    C:\ProgramData\MySQL\MySQL Server 8.0\Data\test_db>dir
     驱动器 C 中的卷是 Windows
     卷的序列号是 FE3C-BF69
    
     C:\ProgramData\MySQL\MySQL Server 8.0\Data\test_db 的目录
    
    2022/08/23  20:56    <DIR>          .
    2022/08/23  20:22    <DIR>          ..
    2022/08/18  11:10           114,688 dept.ibd
    2022/08/18  19:47           131,072 emp.ibd
    2022/08/23  20:56             2,412 my_memory_406.sdi
    2022/08/23  20:50                 0 my_myisam.MYD
    2022/08/23  20:50             1,024 my_myisam.MYI
    2022/08/23  20:50             2,412 my_myisam_405.sdi
    2022/08/19  10:08           114,688 salgrade.ibd
                   7 个文件        366,296 字节
                   2 个目录 94,975,053,824 可用字节
    ```
  
  - **使用指令进行打开(一大串JSON文件)**
  
    ```
    C:\ProgramData\MySQL\MySQL Server 8.0\Data\test_db>ibd2sdi dept.ibd
    ["ibd2sdi"
    ,
    {
            "type": 1,
            "id": 397,
            "object":
                    {
        "mysqld_version_id": 80030,
        "dd_version": 80023,
        "sdi_version": 80019,
        "dd_object_type": "Table",
        "dd_object": {
            "name": "dept",
            "mysql_version_id": 80030,
            "created": 20220818031038,
            "last_altered": 20220818031038,
            "hidden": 1,
            "options": "avg_row_length=0;encrypt_type=N;key_block_size=0;keys_disabled=0;pack_record=1;stats_auto_recalc=0;stats_sample_pages=0;",
            "columns": [
               ...
    ]
    ```



- #### 存储逻辑结构

  - **TableSpace:表空间**

  - **Segment：段**

  - **Extent：区**

  - **Page：页**

  - **Row：行**

**由上而下的包含关系-->**



##### MyISAM

- **介绍**

  MyISAM是MySQL早期默认的存储引擎

- **特点**

  不支持事务，不支持外键

  支持表锁，不支持行锁

  访问速度快

- **文件**

  xxx.sdi: 表存储结构信息

  xxx.MYD : 数据存储

  xxx.MYI : 存储索引



##### **Memory**

- **介绍**

  Memory引擎的数据存储在内存中的，由于受到硬件问题或者断电问题的影响，只能将这些表作为临时表或者缓存使用

- **特点**

  内存存放

  hash索引

- **文件**

  xxx.sdi：存储表结构信息



#### 存储引擎的选择

- **InnoDB：**
  - MySQL的默认存储引擎，如果对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据的操作除了插入和查询之外，**还包含很多的更新、删除操作**，那么InnoDB存储引擎是比较合适的选择。
- **MyISAM：**
  - 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对**事务的完整性、并发性要求不是很高**，那么选择这个存储引擎是非常合适的。（例如日志、商品评价。。。）
- **Memory：**
  - 将所有数据都保存在内存中，访问速度快，通常用于**临时表以及缓存**。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。





#### Linux安装MySQL

- 上传MySQL安装包

- 创建文件夹，并解压

  ```sh
  [root@basenode2 ~]# ll
  total 789340
  -rw-------. 1 root root      1537 Aug 23 00:41 anaconda-ks.cfg
  drwxr-xr-x  3 root root        36 Aug 26 00:57 FfromB1
  -rw-r--r--  1 root root 808273920 Aug 29 22:54 mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar
  -rw-r--r--  1 root root        64 Aug 26 00:53 readme.txt
  [root@basenode2 ~]# tar -xf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql
  
  [root@basenode2 mysql]# ll
  total 789340
  -rw-r--r-- 1 7155 31415  47836256 Jul  2  2021 mysql-community-client-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415   4694644 Jul  2  2021 mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415    634632 Jul  2  2021 mysql-community-common-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415   6806272 Jul  2  2021 mysql-community-devel-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415  23638156 Jul  2  2021 mysql-community-embedded-compat-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415   4243808 Jul  2  2021 mysql-community-libs-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415   1264168 Jul  2  2021 mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415 454689776 Jul  2  2021 mysql-community-server-8.0.26-1.el7.x86_64.rpm
  -rw-r--r-- 1 7155 31415 264457624 Jul  2  2021 mysql-community-test-8.0.26-1.el7.x86_64.rpm
  ```

- **按照顺序进行安装依赖**

  ```sh
  cd mysql
  
  rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm 
  
  rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm 
  
  rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm 
  
  rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm
  
  yum install openssl-devel
  
  rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm
  
  ```

- **安装客户端和服务端**

  ```sh
  rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm
  
  rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm
  ```

- **启动MySQL服务**

  ```sh
  systemctl start mysqld
  ```

- **重启MySQL服务**

  ```sh
  systemctl resstart mysqld
  ```

- **停止MySQL服务**

  ```sh
  systemctl stop mysqld
  ```



**查询自动生成的root用户密码**

- **查看mysql生成的随机密码**

```sh
grep 'temporary password' /var/log/mysqld.log
```

- **命令行执行指令 :**

```sh
mysql -u root -p
```

**然后输入上述查询到的自动生成的密码, 完成登录 .**



- **修改root用户密码**

登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码。

```sql
ALTER  USER  'root'@'localhost'  IDENTIFIED BY '199866';
```

执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。我们可以设置密码的复杂度为简单类型，密码长度为4。

```sql
set global validate_password.policy = 0;
set global validate_password.length = 4;
```

降低密码的校验规则之后，再次执行上述修改密码的指令。



- **创建用户**

默认的root用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个root账户，用户远程访问

```sql
create user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '199866';
```



- **给root用户分配权限**

```
grant all on *.* to 'root'@'%';
```



- **使用DataGrip连接Linux的MySQL**
  - 这里有个坑 ，让我半天都连接不上去，就是在连接卡里面 的Advanced选项中，把useSSL改成**no**



### 2.2 索引

#### 索引概述

- **介绍**

  索引(index)是帮助MySQL**高效获取数据**的**数据结构**(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

- **优缺点**

  - 优势：提高数据检索的效率，降低数据库的I/O成本，通过索引列队数据进行排序，降低数据排序的成本，降低CPU的消耗
  - 劣势：索引列也是要占用空间的，索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行INSERT、UPDATE、DELETE等操作，效率降低。



#### 索引结构

​	MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引类型，大部分的引擎都支持B+树索引                 |
| Hash索引            | 底层数据结构是用hash表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-Tree(空间索引)    | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,ES |

| 索引                | InnoDB      | MyISAM | Memory |
| ------------------- | ----------- | ------ | ------ |
| B+Tree索引          | 支持        | 支持   | 支持   |
| B+Tree索引          | 不支持      | 不支持 | 支持   |
| R-Tree(空间索引)    | 不支持      | 支持   | 不支持 |
| Full-text(全文索引) | 5.6之后支持 | 支持   | 不支持 |

二叉树的缺点：顺序插入时，会形成一个链表，查询的性能大大降低。大量数据的情况下，层级较深，检索速度慢。

红黑树：大量数据的情况下，层级较深，检索速度慢。



- #### **B-Tree(多路平衡查找树)**

  一个树的度数指的是一个节点的子节点个数。

  例如一棵树的最大度数(max-degree)为5，每个节点最多存储4个key，5个指针

  <img src="C:\Users\Hud\AppData\Roaming\Typora\typora-user-images\image-20220902104623651.png" alt="image-20220902104623651" style="zoom:150%;" />

- #### Hash

  Hash索引就是采用一定的Hash算法，键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。0

  如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也成为hash碰撞），可以通过链表来解决

  - **Hash索引的特点**
    - Hash索引只能用于对等比较(=,in)，不支持范围查询(between 、>、<...)
    - 无法利用索引完成排序操作
    - 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree

在MySQL中，支持哈希索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。



- ### 思考：为什么InnoDB存储引擎选择使用B+Tree索引结构？	

  - 相对于二叉树，层级更少，搜索效率更高；
  - B+Tree只有叶子节点才会存放行数据，上面的节点仅仅起到索引的作用，B+Tree的页中不存放行数据，这样可以存放的key和指针就增多了，相同数据量的情况下，B+Tree的层级将会更少
  - 也就是说，对于**B-Tree**--->无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页存储中的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，降低性能。
  - 相对于**Hash索引**（只支持等值匹配），B+Tree支持范围匹配以及排序操作。



#### 索引分类

| **分类**     | **含义**                                             | **特点**                 | **关键字** |
| ------------ | ---------------------------------------------------- | ------------------------ | ---------- |
| **主键索引** | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY    |
| 唯一索引     | 避免同一个表中的某数据列中的值重复                   | 可以有多个               | UNIQUE     |
| 常规索引     | 快速定位特定数据                                     | 可以有多个               |            |
| 全文索引     | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT   |

在InnoDB存储引擎中，根据索引的存储形式，可以分为以下两种：

- **聚集索引(Clustered Index)：**		
  - 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，特点：必须有，而且只有一个
- **二级索引(Secondary Index):**
  - 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，特点：可以存在多个



**聚集索引的选取规则：**

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一索引(UNIQUE)作为聚集索引
- 如果没有主键和合适的唯一索引，InnoDB会自定生成一个rowid作为隐藏的聚集索引

聚集索引下面挂着行数据，而二级索引下面挂着Id（避免数据库数据冗余）

**根据二级索引查询，会触发聚集索引的回表查询**

- #### 思考：InnoDB主键索引的B+Tree高度是多少？

  假设：一行数据的大小是1K，一页（16K）中可以存储16行这样的数据。InnoDB的指针占用固定大小（6个字节空间），key占用的字节取决于主键的类型（例如int：4个字节，bigint：8个字节）

  假设树的高度为2，指针永远比key多一个，可以列出一个公式：(假设主键类型为bigint)

  
  $$
  N*8+(N+1)*6=16*1024
  $$
  N指代的是key的数量，point的数量为N+1，分别乘以所占的字节大小=一页的大小就，解方程得出N的数值，这里N约为1170.

  也就是这里会有1171个指针。一个指针指向一个子节点，而假设一行数据为1KB，那么一页可以存放16行数据，按照这样计算，一个两行的B+Tree可以存放的数据量大概为：		1171*16=18736行数据

- 如果说高度为3，那么我们只需要再*1171，根节点可以有1171个子节点，这1171个子节点有对应了1171个叶子节点。。

  也就是1171 * 1171 * 16=21939856行数据



#### 索引语法

- **创建索引**

  ```sql
  CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
  ```

  如果一个索引只关联一个字段，称之为单链索引，关联多个字段称之为联合索引或者叫组合索引。

  

- **查看索引**

  ```sql
  SHOW INDEX FROM table_name;
  ```



- **删除索引**

  ```SQL
  DROP INDEX index_name ON table_name;
  ```

  

**实例：按照需求，创建索引**

```sql
mysql> select * from tb_user;
+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+
| id | name      | phone       | email                 | profession                  | age  | gender | status | createtime          |
+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+
|  1 | 吕布      | 17799990000 | lvbu666@163.com       | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |
|  2 | 曹操      | 17799990001 | caocao666@qq.com      | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |
|  3 | 赵云      | 17799990002 | 17799990@139.com      | 英语                        |   34 | 1      | 2      | 2002-03-02 00:00:00 |
|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价                    |   54 | 1      | 0      | 2001-07-02 00:00:00 |
|  5 | 花木兰    | 17799990004 | 19980729@sina.com     | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |
|  6 | 大乔      | 17799990005 | daqiao666@sina.com    | 舞蹈                        |   22 | 2      | 0      | 2001-02-07 00:00:00 |
|  7 | 露娜      | 17799990006 | luna_love@sina.com    | 应用数学                    |   24 | 2      | 0      | 2001-02-08 00:00:00 |
|  8 | 程咬金    | 17799990007 | chengyaojin@163.com   | 化工                        |   38 | 1      | 5      | 2001-05-23 00:00:00 |
|  9 | 项羽      | 17799990008 | xiaoyu666@qq.com      | 金属材料                    |   43 | 1      | 0      | 2001-09-18 00:00:00 |
| 10 | 白起      | 17799990009 | baiqi666@sina.com     | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |
| 11 | 韩信      | 17799990010 | hanxin520@163.com     | 无机非金属材料工程          |   27 | 1      | 0      | 2001-06-12 00:00:00 |
| 12 | 荆轲      | 17799990011 | jingke123@163.com     | 会计                        |   29 | 1      | 0      | 2001-05-11 00:00:00 |
| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价                    |   44 | 1      | 1      | 2001-04-09 00:00:00 |
| 14 | 狂铁      | 17799990013 | kuangtie@sina.com     | 应用数学                    |   43 | 1      | 2      | 2001-04-10 00:00:00 |
| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com    | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |
| 16 | 妲己      | 17799990015 | 2783238293@qq.com     | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |
| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济                    |   35 | 2      | 0      | 2000-05-03 00:00:00 |
| 18 | 嬴政      | 17799990017 | 8839434342@qq.com     | 化工                        |   38 | 1      | 1      | 2001-08-08 00:00:00 |
| 19 | 狄仁杰    | 17799990018 | jujiamlm8166@163.com  | 国际贸易                    |   30 | 1      | 0      | 2007-03-12 00:00:00 |
| 20 | 安琪拉    | 17799990019 | jdodm1h@126.com       | 城市规划                    |   51 | 2      | 0      | 2001-08-15 00:00:00 |
| 21 | 典韦      | 17799990020 | ycaunanjian@163.com   | 城市规划                    |   52 | 1      | 2      | 2000-04-12 00:00:00 |
| 22 | 廉颇      | 17799990021 | lianpo321@126.com     | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |
| 23 | 后羿      | 17799990022 | altycj2000@139.com    | 城市园林                    |   20 | 1      | 0      | 2002-03-10 00:00:00 |
| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价                    |   29 | 1      | 4      | 2003-05-26 00:00:00 |
+----+-----------+-------------+-----------------------+-----------------------------+------+--------+--------+---------------------+
24 rows in set (0.00 sec)

```

1. name字段为姓名字段，该字段值可能会重复，为该字段创建索引
2. phone手机号字段的值，是非空且唯一的，为该字段创建索引
3. 为profession、age、status创建联合索引
4. 为email建立合适的索引来提升查询效率

```sql
# 查看有什么索引
mysql> SHOW INDEX FROM  tb_user\G;
*************************** 1. row ***************************
        Table: tb_user
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
1 row in set (0.00 sec)

ERROR: 
No query specified

# 目前只有主键索引 BTREE类型（B+）
```

- **为name创建索引**

```sql
#创建NAME索引
CREATE INDEX idx_user_name ON tb_user(name);
mysql> SHOW INDEX FROM  tb_user\G;
*************************** 1. row ***************************
        Table: tb_user
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
*************************** 2. row ***************************
        Table: tb_user
   Non_unique: 1
     Key_name: idx_user_name
 Seq_in_index: 1
  Column_name: name
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
2 rows in set (0.00 sec)

ERROR: 
No query specified
# 创建了name字段的索引名称为idx_user_name，B+TREE(InnoDB的默认索引结构)
```

- **为phone字段创建非空唯一索引**

```sql
CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);
*************************** 2. row ***************************
        Table: tb_user
   Non_unique: 0
     Key_name: idx_user_phone
 Seq_in_index: 1
  Column_name: phone
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
```

- **创建profession、age、status创建联合索引**

```sql
CREATE INDEX idx_pro_age_sta ON tb_user(profession,age,status)
*************************** 4. row ***************************
        Table: tb_user
   Non_unique: 1
     Key_name: idx_pro_age_sta
 Seq_in_index: 1
  Column_name: profession
    Collation: A
  Cardinality: 16
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
*************************** 5. row ***************************
        Table: tb_user
   Non_unique: 1
     Key_name: idx_pro_age_sta
 Seq_in_index: 2
  Column_name: age
    Collation: A
  Cardinality: 22
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
*************************** 6. row ***************************
        Table: tb_user
   Non_unique: 1
     Key_name: idx_pro_age_sta
 Seq_in_index: 3
  Column_name: status
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
6 rows in set (0.01 sec)
```

- **为email创建索引**

```SQL
CREATE INDEX idx_user_email ON tb_user(EMAIL);
*************************** 7. row ***************************
        Table: tb_user
   Non_unique: 1
     Key_name: idx_user_email
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 24
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
7 rows in set (0.00 sec)

```



#### SQL性能分析

优化主要优化的是查询语句

- **SQL的执行频率**

  - MySQL客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次

  ```
  SHOW GLOBAL STATUS LIKE 'Com_______'   #七个下划线
  ```

- **慢查询日志**

  慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志。

  MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息

  ```sql
  #查看慢查询日志开关
  mysql> SHOW VARIABLES LIKE 'slow_query_log';
  +----------------+-------+
  | Variable_name  | Value |
  +----------------+-------+
  | slow_query_log | OFF   |
  +----------------+-------+
  1 row in set (0.00 sec)
  #可以看到默认是关闭状态
  ```

  ```bash
  #开启MySQL慢日志查询开关
  slow_query_log = 1
  #设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志
  long_query_time = 2
  ```

  配置完毕之后，通过以下指令重启MySQL服务器进行测试，查看慢日志文件中记录的信息**/var/lib/mysql/localhost-slow.log**

  ```sh
  [root@basenode2 ~]# systemctl restart mysqld
  ```

  **再次查询**

  ```sql
  mysql> SHOW VARIABLES LIKE 'slow_query_log';
  ERROR 2013 (HY000): Lost connection to MySQL server during query
  No connection. Trying to reconnect...
  Connection id:    8
  Current database: itcast
  
  +----------------+-------+
  | Variable_name  | Value |
  +----------------+-------+
  | slow_query_log | ON    |
  +----------------+-------+
  1 row in set (0.04 sec)
  ```

  **查看文件**

  ```shell
  [root@basenode2 mysql]# cat basenode2-slow.log 
  /usr/sbin/mysqld, Version: 8.0.26 (MySQL Community Server - GPL). started with:
  Tcp port: 3306  Unix socket: /var/lib/mysql/mysql.sock
  Time                 Id Command    Argument
  ```

- #### * 查看mysql文件位置 *


```sql
mysql> show variables like '%dir%';
```

- ### profile详情

  show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前SQL是否支持profile操作：

  ```sql
  mysql> SELECT @@HAVE_PROFILING;
  +------------------+
  | @@HAVE_PROFILING |
  +------------------+
  | YES              |
  +------------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  查询现在profiling状态：

  ```sql
  mysql> select @@profiling;
  +-------------+
  | @@profiling |
  +-------------+
  |           0 |
  +-------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  默认profiling是关闭的，可以通过set语句在session/global级别开启profiling

  ```sql
  SET [session/global] profiling=1;
  mysql> SET profiling=1;
  Query OK, 0 rows affected, 1 warning (0.00 sec)
  
  mysql> select @@profiling;
  +-------------+
  | @@profiling |
  +-------------+
  |           1 |
  +-------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  **查看profile表：**

  ```sql
  # 查看每一条SQL的耗时基本情况
  mysql> show profiles;
  +----------+------------+----------------------------------+
  | Query_ID | Duration   | Query                            |
  +----------+------------+----------------------------------+
  |        1 | 0.00086900 | select @@profiling               |
  |        2 | 0.11649725 | show tables                      |
  |        3 | 0.15416725 | select * from tb_user            |
  |        4 | 0.00093175 | select * from tb_user where id=5 |
  +----------+------------+----------------------------------+
  4 rows in set, 1 warning (0.00 sec)
  ```

  **查看阶段耗时情况**

  show profile for query [query_id];

  ```sql
  mysql> show profile for query 3;
  +--------------------------------+----------+
  | Status                         | Duration |
  +--------------------------------+----------+
  | starting                       | 0.000197 |
  | Executing hook on transaction  | 0.000194 |
  | starting                       | 0.000014 |
  | checking permissions           | 0.000010 |
  | Opening tables                 | 0.000350 |
  | init                           | 0.000008 |
  | System lock                    | 0.000170 |
  | optimizing                     | 0.000006 |
  | statistics                     | 0.000157 |
  | preparing                      | 0.000035 |
  | executing                      | 0.152924 |
  | end                            | 0.000013 |
  | query end                      | 0.000004 |
  | waiting for handler commit     | 0.000009 |
  | closing tables                 | 0.000010 |
  | freeing items                  | 0.000033 |
  | cleaning up                    | 0.000034 |
  +--------------------------------+----------+
  17 rows in set, 1 warning (0.16 sec)
  ```

​		也可以看到cpu使用情况：

```sql
mysql> show profile cpu  for query 3;
+--------------------------------+----------+----------+------------+
| Status                         | Duration | CPU_user | CPU_system |
+--------------------------------+----------+----------+------------+
| starting                       | 0.000197 | 0.000191 |   0.000000 |
| Executing hook on transaction  | 0.000194 | 0.000193 |   0.000000 |
| starting                       | 0.000014 | 0.000014 |   0.000000 |
| checking permissions           | 0.000010 | 0.000010 |   0.000000 |
| Opening tables                 | 0.000350 | 0.000350 |   0.000000 |
| init                           | 0.000008 | 0.000007 |   0.000000 |
| System lock                    | 0.000170 | 0.000170 |   0.000000 |
| optimizing                     | 0.000006 | 0.000006 |   0.000000 |
| statistics                     | 0.000157 | 0.000157 |   0.000000 |
| preparing                      | 0.000035 | 0.000035 |   0.000000 |
| executing                      | 0.152924 | 0.092291 |   0.074671 |
| end                            | 0.000013 | 0.000002 |   0.000005 |
| query end                      | 0.000004 | 0.000001 |   0.000002 |
| waiting for handler commit     | 0.000009 | 0.000004 |   0.000007 |
| closing tables                 | 0.000010 | 0.000003 |   0.000006 |
| freeing items                  | 0.000033 | 0.000000 |   0.000033 |
| cleaning up                    | 0.000034 | 0.000000 |   0.000034 |
+--------------------------------+----------+----------+------------+
17 rows in set, 1 warning (0.00 sec)
```



- ### explain执行计划

  EXPLAIN获得DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT执行过程中如何连接和连接的顺序。

  语法：

  ​		直接在任意的SELECT语句前加上关键字`EXPLAIN/DESC`

  ```sql
  mysql> explain select * from tb_user where id=5 ;
  +----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  | id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
  +----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | tb_user | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
  +----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```

  举个例子,查看一个多表查询的explain

  ```sql
  mysql> explain SELECT S.*,C.* FROM STUDENT S,COURSE C,STUDENT_COURSE SC WHERE S.ID = SC.STUDENTID AND C.ID = SC.COURSEID;
  +----+-------------+-------+------------+--------+--------------------------+-------------+---------+---------------------+------+----------+-------+
  | id | select_type | table | partitions | type   | possible_keys            | key         | key_len | ref                 | rows | filtered | Extra |
  +----+-------------+-------+------------+--------+--------------------------+-------------+---------+---------------------+------+----------+-------+
  |  1 | SIMPLE      | C     | NULL       | ALL    | PRIMARY                  | NULL        | NULL    | NULL                |    4 |   100.00 | NULL  |
  |  1 | SIMPLE      | SC    | NULL       | ref    | FK_STUDENTID,FK_COURSEID | FK_COURSEID | 4       | itcast.C.ID         |    3 |   100.00 | NULL  |
  |  1 | SIMPLE      | S     | NULL       | eq_ref | PRIMARY                  | PRIMARY     | 4       | itcast.SC.STUDENTID |    1 |   100.00 | NULL  |
  +----+-------------+-------+------------+--------+--------------------------+-------------+---------+---------------------+------+----------+-------+
  3 rows in set, 1 warning (0.00 sec)
  
  ```

  Explain执行计划各字段含义

  - **Id**

    Select查询的序列号，表示查询中执行select子句或是操作表的顺序（id相同，执行顺序从上到下，id不同，值越大，越先执行）

  - **select_type**

    表示SELECT的类型，常见的有SIMPLE(简单表，即不使用表连接或子查询)，PRIMARY(主查询，即外层的查询)、UNION(UNION中的第二个或者后面的查询语句)、SUBQUERY(SELECT/WHERE之后包含了子查询)等

  - **type**

    表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all.

    我们在对SQL语句进行优化的时候，需要尽量向前优化，否则性能会比较低。

    (NULL在我们的实际业务中基本不可能出现，system通常是查询系统表，const通常为唯一索引，ref通常为非唯一索引，index表示虽然使用了索引，但是会对索引树进行遍历)

  - **possible_key**

    显示可能应用在这张表上的索引，一个或者多个

  - **Key**

    实际用到的索引，如果为NULL就是没有用到索引

  - **Key_len**

    表示索引中使用的字节数，该值为索引字段最大可能的长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好

  - **rows**

    MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的

  - **filtered**

    表示返回结果的行数占需读取的行数的百分比，filtered的数值越大越好

  - **extra**

    表示额外信息



#### 索引使用原则

- ##### 验证索引效率

  对于拥有1000w条数据的表tb_sku，在未建立索引之前，执行如下的SQL语句，查看SQL的耗时

  ```sql
  mysql> SELECT * FROM tb_sku WHERE sn = '10000000314500419'\G;
  *************************** 1. row ***************************
             id: 419
             sn: 10000000314500419
           name: 华为Meta419
          price: 23519
            num: 10000
      alert_num: 100
          image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/871/30/6057/429001/5ba064e6E5a6211eb/a8450f6b73a8a29f.jpg!q70.jpg.webp
         images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/871/30/6057/429001/5ba064e6E5a6211eb/a8450f6b73a8a29f.jpg!q70.jpg.webp
         weight: 10
    create_time: 2019-05-01 00:00:00
    update_time: 2019-05-01 00:00:00
  category_name: 牛仔裤
     brand_name: 丽乔
           spec: 白色419
       sale_num: 0
    comment_num: 0
         status: 1
  1 row in set (10.88 sec)
  
  ```

  可以看到这个查找语句的效率极低，下面我们创建索引(其实也就是为该字段创建B+树的过程)

  ```sql
  # 创建索引
  mysql> create index idx_sku_sn on tb_sku(sn);
  Query OK, 0 rows affected (37.61 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  # 再次执行一次查询
  mysql> SELECT * FROM tb_sku WHERE sn = '10000000314500421'\G;
  *************************** 1. row ***************************
             id: 421
             sn: 10000000314500421
           name: 华为Meta421
          price: 98221
            num: 10000
      alert_num: 100
          image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/871/30/6057/429001/5ba064e6E5a6211eb/a8450f6b73a8a29f.jpg!q70.jpg.webp
         images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t1/871/30/6057/429001/5ba064e6E5a6211eb/a8450f6b73a8a29f.jpg!q70.jpg.webp
         weight: 10
    create_time: 2019-05-01 00:00:00
    update_time: 2019-05-01 00:00:00
  category_name: 牛仔裤
     brand_name: 丽乔
           spec: 白色421
       sale_num: 0
    comment_num: 0
         status: 1
  1 row in set (0.00 sec)
  
  ```

  发现创建索引后，查询效率高了很多很多，查看一下查询计划

  ```sql
  mysql> explain SELECT * FROM tb_sku WHERE sn = '10000000314500421';
  +----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
  | id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
  +----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | tb_sku | NULL       | ref  | idx_sku_sn    | idx_sku_sn | 402     | const |    1 |   100.00 | NULL  |
  +----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```

  **用到了idx_sku_sn索引**



- #### 最左前缀法则

  如果索引了多列(联合索引)，要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列

  如果跳跃某一列，索引将部分失效(后面的字段索引失效)

  ```sql
  mysql> SELECT * FROM  tb_user WHERE profession = '软件工程' and age=31 and status ='0';
  +----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
  | id | name   | phone       | email             | profession   | age  | gender | status | createtime          |
  +----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
  | 16 | 妲己   | 17799990015 | 2783238293@qq.com | 软件工程     |   31 | 2      | 0      | 2001-01-30 00:00:00 |
  +----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
  1 row in set (0.10 sec)
  
  mysql> explain SELECT * FROM  tb_user WHERE profession = '软件工程' and age=31 and status ='0';
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------------+------+----------+-----------------------+
  | id | select_type | table   | partitions | type | possible_keys   | key             | key_len | ref               | rows | filtered | Extra                 |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------------+------+----------+-----------------------+
  |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_pro_age_sta | idx_pro_age_sta | 54      | const,const,const |    1 |   100.00 | Using index condition |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain SELECT * FROM  tb_user WHERE profession = '软件工程' and age=31;
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------+------+----------+-------+
  | id | select_type | table   | partitions | type | possible_keys   | key             | key_len | ref         | rows | filtered | Extra |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------+------+----------+-------+
  |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_pro_age_sta | idx_pro_age_sta | 49      | const,const |    1 |   100.00 | NULL  |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain SELECT * FROM  tb_user WHERE profession = '软件工程' and  status ='0';
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------+------+----------+-----------------------+
  | id | select_type | table   | partitions | type | possible_keys   | key             | key_len | ref   | rows | filtered | Extra                 |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------+------+----------+-----------------------+
  |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_pro_age_sta | idx_pro_age_sta | 47      | const |    4 |    10.00 | Using index condition |
  +----+-------------+---------+------------+------+-----------------+-----------------+---------+-------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain SELECT * FROM  tb_user WHERE  age=31 and status ='0';
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |     4.17 | Using where |
  +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)
  
  ```

  看起来比较麻烦，简单点说就是因为是联合索引，但是在查询中没有满足最左前缀法则，所以最后一条查询计划显示，整个索引都失效了

  一定要包含最左边的列。

  如果没有最左边列，则全部失效，如果跳过某一列则部分失效（存在即可，与位置无关）



- ### 范围查询

  联合索引中，出现范围查询(<,>)**范围查询右侧的列索引失效**

  ```sql
  mysql> explain SELECT * FROM  tb_user WHERE profession = '软件工程' and age>30 and status ='0';
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  | id | select_type | table   | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | tb_user | NULL       | range | idx_pro_age_sta | idx_pro_age_sta | 49      | NULL |    2 |    10.00 | Using index condition |
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain SELECT * FROM  tb_user WHERE profession = '软件工程' and age>=30 and status ='0';
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  | id | select_type | table   | partitions | type  | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | tb_user | NULL       | range | idx_pro_age_sta | idx_pro_age_sta | 54      | NULL |    2 |    10.00 | Using index condition |
  +----+-------------+---------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  我们在实际过程中，尽量使用`>=、<=`可以看到这样可以不让索引失效(业务允许的情况下，尽量使用`>=、<=`)



- ### **索引列运算**

  不要在索引列上进行运算操作，索引将失效

  **现在我们要查询手机号码最后两位是15的用户**

```
mysql> SELECT * FROM tb_user WHERE SUBSTRING(phone,10,2) = '15';
+----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
| id | name   | phone       | email             | profession   | age  | gender | status | createtime          |
+----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
| 16 | 妲己   | 17799990015 | 2783238293@qq.com | 软件工程     |   31 | 2      | 0      | 2001-01-30 00:00:00 |
+----+--------+-------------+-------------------+--------------+------+--------+--------+---------------------+
1 row in set (0.00 sec)

mysql> explain SELECT * FROM tb_user WHERE SUBSTRING(phone,10,2) = '15';
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   24 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.36 sec)
```

可以看到这里，语法的效率并不高，type为ALL是全表扫描，因为对phone字段进行了函数运算，导致这个字段的索引已经失效了



- ### 字符串不加引号	

  字符串型字段在使用时，如果不加单引号，该字段的索引将会失效。

  ```sql
  mysql> explain SELECT * FROM tb_user  WHERE profession = '软件工程' and age = 31 and status = '0'\G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: ref
  possible_keys: idx_pro_age_sta
            key: idx_pro_age_sta
        key_len: 54
            ref: const,const,const
           rows: 1
       filtered: 100.00
          Extra: Using index condition
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain SELECT * FROM tb_user  WHERE profession = '软件工程' and age = 31 and status = 0\G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: ref
  possible_keys: idx_pro_age_sta
            key: idx_pro_age_sta
        key_len: 49
            ref: const,const
           rows: 1
       filtered: 10.00
          Extra: Using index condition
  1 row in set, 2 warnings (0.00 sec)
  
  ERROR: 
  No query specified
  
  ```

  这里可以看到索引长度变短了，其实也就是status的索引失效了



- ### 模糊查询

  如果仅仅只是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。

```sql
mysql> SELECT * FROM tb_user WHERE profession LIKE '工%';
+----+-----------+-------------+-----------------------+--------------+------+--------+--------+---------------------+
| id | name      | phone       | email                 | profession   | age  | gender | status | createtime          |
+----+-----------+-------------+-----------------------+--------------+------+--------+--------+---------------------+
| 17 | 芈月      | 17799990016 | xiaomin2001@sina.com  | 工业经济     |   35 | 2      | 0      | 2000-05-03 00:00:00 |
| 24 | 姜子牙    | 17799990023 | 37483844@qq.com       | 工程造价     |   29 | 1      | 4      | 2003-05-26 00:00:00 |
| 13 | 兰陵王    | 17799990012 | lanlinwang666@126.com | 工程造价     |   44 | 1      | 1      | 2001-04-09 00:00:00 |
|  4 | 孙悟空    | 17799990003 | 17799990@sina.com     | 工程造价     |   54 | 1      | 0      | 2001-07-02 00:00:00 |
+----+-----------+-------------+-----------------------+--------------+------+--------+--------+---------------------+
# 联合索引的第一个字段，符合最左前缀法则，所以使用了索引

mysql> explain SELECT * FROM tb_user WHERE profession LIKE '工%'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: range
possible_keys: idx_pro_age_sta
          key: idx_pro_age_sta
      key_len: 47
          ref: NULL
         rows: 4
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

**现在看看头部模糊索引**：

```sql
mysql> SELECT * FROM tb_user WHERE profession LIKE '%工程';
+----+-----------+-------------+--------------------+-----------------------------+------+--------+--------+--------------------
| id | name      | phone       | email              | profession                  | age  | gender | status | createtime        |
+----+-----------+-------------+--------------------+-----------------------------+------+--------+--------+--------------------
|  1 | 吕布      | 17799990000 | lvbu666@163.com    | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |
|  2 | 曹操      | 17799990001 | caocao666@qq.com   | 通讯工程                    |   33 | 1      | 0      | 2001-03-05 00:00:00 |
|  5 | 花木兰    | 17799990004 | 19980729@sina.com  | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |
| 11 | 韩信      | 17799990010 | hanxin520@163.com  | 无机非金属材料工程          |   27 | 1      | 0        | 2001-06-12 00:00:00 |
| 15 | 貂蝉      | 17799990014 | 84958948374@qq.com | 软件工程                    |   40 | 2      | 3      | 2001-02-12 00:00:00 |
| 16 | 妲己      | 17799990015 | 2783238293@qq.com  | 软件工程                    |   31 | 2      | 0      | 2001-01-30 00:00:00 |
| 22 | 廉颇      | 17799990021 | lianpo321@126.com  | 土木工程                    |   19 | 1      | 3      | 2002-07-18 00:00:00 |
+----+-----------+-------------+--------------------+-----------------------------+------+--------+--------+-------------------+
7 rows in set (0.00 sec)

mysql> explain SELECT * FROM tb_user WHERE profession LIKE '%工程'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 24
     filtered: 11.11
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

这里看到，这个查询语句是没有走索引的，只要在头部加了%，索引就会失效。



1. ### or连接的条件

   用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到

   也就是or连接的两侧的列中都有索引的时候，索引才会生效

   ```sql
   mysql> show index from tb_user\G;
   *************************** 1. row ***************************
           Table: tb_user
      Non_unique: 0
        Key_name: PRIMARY
    Seq_in_index: 1
     Column_name: id
       Collation: A
     Cardinality: 24
        Sub_part: NULL
          Packed: NULL
            Null: 
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 2. row ***************************
           Table: tb_user
      Non_unique: 0
        Key_name: idx_user_phone
    Seq_in_index: 1
     Column_name: phone
       Collation: A
     Cardinality: 24
        Sub_part: NULL
          Packed: NULL
            Null: 
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 3. row ***************************
           Table: tb_user
      Non_unique: 1
        Key_name: idx_user_name
    Seq_in_index: 1
     Column_name: name
       Collation: A
     Cardinality: 24
        Sub_part: NULL
          Packed: NULL
            Null: 
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 4. row ***************************
           Table: tb_user
      Non_unique: 1
        Key_name: idx_pro_age_sta
    Seq_in_index: 1
     Column_name: profession
       Collation: A
     Cardinality: 16
        Sub_part: NULL
          Packed: NULL
            Null: YES
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 5. row ***************************
           Table: tb_user
      Non_unique: 1
        Key_name: idx_pro_age_sta
    Seq_in_index: 2
     Column_name: age
       Collation: A
     Cardinality: 22
        Sub_part: NULL
          Packed: NULL
            Null: YES
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 6. row ***************************
           Table: tb_user
      Non_unique: 1
        Key_name: idx_pro_age_sta
    Seq_in_index: 3
     Column_name: status
       Collation: A
     Cardinality: 24
        Sub_part: NULL
          Packed: NULL
            Null: YES
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   *************************** 7. row ***************************
           Table: tb_user
      Non_unique: 1
        Key_name: idx_user_email
    Seq_in_index: 1
     Column_name: email
       Collation: A
     Cardinality: 24
        Sub_part: NULL
          Packed: NULL
            Null: YES
      Index_type: BTREE
         Comment: 
   Index_comment: 
         Visible: YES
      Expression: NULL
   7 rows in set (0.00 sec)
   
   ERROR: 
   No query specified
   
   ```

   查看当前表中的索引，**age字段**是没有添加索引的。

   **执行查询语句：**

   ```sql
   mysql> select * from tb_user where id=10 or age=23;
   +----+-----------+-------------+-------------------+-----------------------------+------+--------+--------+---------------------+
   | id | name      | phone       | email             | profession                  | age  | gender | status | createtime          |
   +----+-----------+-------------+-------------------+-----------------------------+------+--------+--------+---------------------+
   |  1 | 吕布      | 17799990000 | lvbu666@163.com   | 软件工程                    |   23 | 1      | 6      | 2001-02-02 00:00:00 |
   |  5 | 花木兰    | 17799990004 | 19980729@sina.com | 软件工程                    |   23 | 2      | 1      | 2001-04-22 00:00:00 |
   | 10 | 白起      | 17799990009 | baiqi666@sina.com | 机械工程及其自动化          |   27 | 1      | 2      | 2001-08-16 00:00:00 |
   +----+-----------+-------------+-------------------+-----------------------------+------+--------+--------+---------------------+
   3 rows in set (0.00 sec)
   
   mysql> explain select * from tb_user where id=10 or age=23;
   +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
   | id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
   +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
   |  1 | SIMPLE      | tb_user | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |   24 |    13.75 | Using where |
   +----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
   1 row in set, 1 warning (0.00 sec)
   
   ```

   可以看到，虽然id字段被添加了索引，但失效了。

   创建一个索引在age上面，看看执行计划会不会被改变。

   ```sql
   mysql> create index idx_user_age on tb_user(age);
   Query OK, 0 rows affected (0.36 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   
   mysql> explain select * from tb_user where id=10 or age=23;
   +----+-------------+---------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
   | id | select_type | table   | partitions | type        | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                                          |
   +----+-------------+---------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
   |  1 | SIMPLE      | tb_user | NULL       | index_merge | PRIMARY,idx_user_age | PRIMARY,idx_user_age | 4,2     | NULL |    3 |   100.00 | Using union(PRIMARY,idx_user_age); Using where |
   +----+-------------+---------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
   1 row in set, 1 warning (0.01 sec)
   ```



- ### 数据分布影响

  如果MySQL评估使用索引比全表更慢，则不使用索引。

  ```sql
  mysql> explain select * from tb_user where phone >= '17799990020';
  +----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
  | id | select_type | table   | partitions | type  | possible_keys  | key            | key_len | ref  | rows | filtered | Extra                 |
  +----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
  |  1 | SIMPLE      | tb_user | NULL       | range | idx_user_phone | idx_user_phone | 46      | NULL |    4 |   100.00 | Using index condition |
  +----+-------------+---------+------------+-------+----------------+----------------+---------+------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain select * from tb_user where phone >= '17799990000';
  +----+-------------+---------+------------+------+----------------+------+---------+------+------+----------+-------------+
  | id | select_type | table   | partitions | type | possible_keys  | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+---------+------------+------+----------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | tb_user | NULL       | ALL  | idx_user_phone | NULL | NULL    | NULL |   24 |   100.00 | Using where |
  +----+-------------+---------+------------+------+----------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)
  ```

  从上面可以看到，因为phone >= '17799990000'这种查询条件，可以将全表所有数据都给你查出来，mysql评估发现你这个用了索引还他妈的不如不用，所以索引也在此时失效了，直接进行全表查询。（主要取决于数据的分布情况）



- ### SQL提示

  SQL提示，是优化数据库的一个重要手段，简单来说就是在SQL语句中加入一些人为的提示来达到优化操作的目的。

  先对profession创建单列索引

  - ##### use index:（告诉数据库你建议使用哪个索引）

    ```sql
    mysql> explain select * from tb_user use index(idx_user_pro) where profession='软件工程';
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    | id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    
    ```

    可以看到使用了`idx_user_pro`索引而不是联合索引

    

  - ##### ignore index(告诉数据库忽略某个索引)

    ```
    mysql> explain select * from tb_user ignore index(idx_pro_age_sta) where profession='软件工程';
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    | id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    
    ```

    

  - ##### force index(规定数据库必须走这个索引)

    ```sql
    mysql> explain select * from tb_user force index(idx_user_pro) where profession='软件工程';
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    | id | select_type | table   | partitions | type | possible_keys | key          | key_len | ref   | rows | filtered | Extra |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | tb_user | NULL       | ref  | idx_user_pro  | idx_user_pro | 47      | const |    4 |   100.00 | NULL  |
    +----+-------------+---------+------------+------+---------------+--------------+---------+-------+------+----------+-------+
    1 row in set, 1 warning (0.00 sec)
    ```



- ### 覆盖索引

  在查询当中，尽量的使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少`select *`

```sql
mysql> explain select id,profession,age,status from tb_user where profession = '软件工程' and age = 31 and status = '0'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: ref
possible_keys: idx_pro_age_sta
          key: idx_pro_age_sta
      key_len: 54
          ref: const,const,const
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> explain select id,profession,age,status,name from tb_user where profession = '软件工程' and age = 31 and status = '0'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: ref
possible_keys: idx_pro_age_sta
          key: idx_pro_age_sta
      key_len: 54
          ref: const,const,const
         rows: 1
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

```

**Using index condition：**查找使用了索引，但是需要回表查询数据

**Using where; Using index：**查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据

如果查询返回的字段，在索引中都有，那么就不涉及到回表查询操作了



- ### 前缀索引

​		当字段类型为字符串(varchar，text等)时，有时候索引长度很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

**创建前缀索引的语法**

```sql
create index idx_xxxx on table_name(column(n));
```

**前缀长度**

可以根据索引的选择性来决定，而选择性是只不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

求选择性，以tb_user表为例，求email字段的选择性

```sql
#email字段的不重复值
mysql> select count(distinct email) from tb_user;
+-----------------------+
| count(distinct email) |
+-----------------------+
|                    24 |
+-----------------------+
1 row in set (0.00 sec)

#求email字段的选择性
mysql> select count(distinct email)/count(*) from tb_user;
+--------------------------------+
| count(distinct email)/count(*) |
+--------------------------------+
|                         1.0000 |
+--------------------------------+
1 row in set (0.00 sec)
```

利用substring函数截取

**看看多少字符的时候选择性下降了**

```sql
mysql> select count(distinct substring(email,1,10))/count(*) from tb_user;
+------------------------------------------------+
| count(distinct substring(email,1,10))/count(*) |
+------------------------------------------------+
|                                         1.0000 |
+------------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,9))/count(*) from tb_user;
+-----------------------------------------------+
| count(distinct substring(email,1,9))/count(*) |
+-----------------------------------------------+
|                                        0.9583 |
+-----------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,5))/count(*) from tb_user;
+-----------------------------------------------+
| count(distinct substring(email,1,5))/count(*) |
+-----------------------------------------------+
|                                        0.9583 |
+-----------------------------------------------+
1 row in set (0.00 sec)
```

创建一个email字段的前缀索引：

```sql
mysql> create index idx_email_5 on tb_user(email(5));
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show index from tb_user;
+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table   | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| tb_user |          0 | PRIMARY         |            1 | id          | A         |          24 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| tb_user |          0 | idx_user_phone  |            1 | phone       | A         |          24 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| tb_user |          1 | idx_user_name   |            1 | name        | A         |          24 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| tb_user |          1 | idx_pro_age_sta |            1 | profession  | A         |          16 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| tb_user |          1 | idx_pro_age_sta |            2 | age         | A         |          22 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| tb_user |          1 | idx_pro_age_sta |            3 | status      | A         |          24 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| tb_user |          1 | idx_email_5     |            1 | email       | A         |          23 |        5 |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
7 rows in set (0.00 sec)

```

 **Sub_part** 就是截取部分

现在执行一次查询，看看有没有生效

```sql
mysql>  select * from tb_user where email = 'daqiao666@sina.com';
+----+--------+-------------+--------------------+------------+------+--------+--------+---------------------+
| id | name   | phone       | email              | profession | age  | gender | status | createtime          |
+----+--------+-------------+--------------------+------------+------+--------+--------+---------------------+
|  6 | 大乔   | 17799990005 | daqiao666@sina.com | 舞蹈       |   22 | 2      | 0      | 2001-02-07 00:00:00 |
+----+--------+-------------+--------------------+------------+------+--------+--------+---------------------+
1 row in set (0.00 sec)

mysql> explain select * from tb_user where email = 'daqiao666@sina.com';
+----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | tb_user | NULL       | ref  | idx_email_5   | idx_email_5 | 23      | const |    1 |   100.00 | Using where |
+----+-------------+---------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```



- ### 单列索引和联合索引

​	单列索引：一个索引只包含单个列

​	联合索引：一个索引包含多个列

​	创建联合索引：

```sql
mysql> create unique index idx_user_phone_name on tb_user(phone,name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

#查看查询计划
mysql> explain select id,phone,name from tb_user where phone='17799990010' and name='韩信'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: const
possible_keys: idx_user_phone,idx_user_phone_name,idx_user_name
          key: idx_user_phone
      key_len: 46
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

使用覆盖索引，不需要回表查询

**所以，我们推荐使用联合索引**

在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议使用联合索引。



- ### 索引设计原则

  1. 针对于数据量较大，且查询比较繁重的表建立索引
  2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引
  3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的频率越高
  4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
  5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
  6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
  7. 如果索引列不能存储NULL值，请在创建表时候使用NOT NULL约束他。当优化器知道每列是否包含NULL值时，他可以更好的确定哪个索引最有效的用于查询。



#### 索引小结

1. **索引概述**

   索引是高效获取数据的数据结构

2.  **索引结构**

   B+Tree

   Hash

3. **索引分类**

   - 主键索引、唯一 索引、常规索引、全文索引
   - 聚集索引、二级索引

4. **索引语法**

   ```sql
   create [unique] index idx_name on table_name(字段名);
   show index from table_name;
   drop index xxx on xxx;
   ```

5. **SQL性能分析**

   - 执行频次、慢日志查询、profile、explain

6. **索引使用**

   - 联合索引
   - 索引失效
   - SQL提示
   - 覆盖索引
   - 前缀索引
   - 单列/联合索引

7. **索引设计原则**

   表 字段 索引



### 2.3 SQL优化

#### 插入数据优化



- #### INSERT优化

  - **批量插入（每次都要建立连接，性能低下）**

  ```sql
  Insert into tb_test values(1,'Hud'),(2,'Monica'),(3,'Qb');
  ```

  - **手动提交事务**

  ```sql
  start transaction;
  insert into tb_test values(1,'Hud'),(2,'Monica'),(3,'Qb');
  insert into tb_test values(4,'Hud'),(5,'Monica'),(6,'Qb');
  insert into tb_test values(7,'Hud'),(8,'Monica'),(9,'Qb');
  commit;
  ```

  - **主键顺序插入**

    在插入数据时，按照主键顺序由小到大排序可以获得更好的性能



- #### 大批量的插入数据

  如果一次性需要插入大批量的数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入，操作如下

  ```sql
  #客户端连接服务端时，加上参数 --local-infile
  mysql--local-infile -u root -p
  
  #设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
  set global local_infile=1;
  
  #执行load指令  每个字段之间使用","分隔 
  load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';
  ```



#### 主键优化

- #### 数据组织方式

  在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table IOT）。

  聚集索引下的叶子节点挂着这一行的行数据

  ```sql
  TableSpace: 表空间 （存储着许多Segment）
  Segment: 段 （存放着一个个的Extent）
  Extent: 区	一个区的大小固定为1M，可以包含64个Page
  Page: 页		一个页的大小固定为 存放着一个个的Row InnoDB管理的最小单元 默认大小为16K
  Row: 行		存放着具体的字段值
  ```



- #### 页分裂

  页可以为空，也可以填充一半，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会发生行溢出），根据主键排列。

  在主键乱序插入的情况下，就有可能会有页分裂的情况发生

  

- #### 页合并

  当删除一行数据时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除且它的空间变得允许被其他记录声明使用。

  当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用

  MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引的时候设置。



- #### 主键设计原则

  - 满足业务需求的情况下，尽量降低主键的长度
  - 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键
  - 尽量不要使用UUID做主键或者是其他自然主键，例如身份证号（UUID往往是无序的）
  - 业务操作时，避免对主键的修改



#### Order by优化

排序操作的优化

- Using filesort：通过表的索引或者全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通索引直接返回排序结果的排序都叫FileSort排序

- Using Index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高

  在表tb_user中删除一部分索引，查看排序的执行计划

  ```sql
  mysql> show index from tb_user;
  +---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  | Table   | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
  +---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  | tb_user |          0 | PRIMARY         |            1 | id          | A         |          24 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
  | tb_user |          1 | idx_pro_age_sta |            1 | profession  | A         |          16 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
  | tb_user |          1 | idx_pro_age_sta |            2 | age         | A         |          22 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
  | tb_user |          1 | idx_pro_age_sta |            3 | status      | A         |          24 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
  +---------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
  4 rows in set (0.00 sec)
  
  mysql> explain select id , age ,phone from tb_user order by age\G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 24
       filtered: 100.00
          Extra: Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  
  ```

  看到了：Using filesort，这种的执行效率是比较低的

  创建一个索引，看看执行计划：

  ```sql
  mysql> create index idx_user_age_phone on tb_user(age,phone);
  Query OK, 0 rows affected (0.36 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> explain select id , age ,phone from tb_user order by age\G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: index
  possible_keys: NULL
            key: idx_user_age_phone
        key_len: 48
            ref: NULL
           rows: 24
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

  可以看到这个时候排序的执行计划是使用了索引

  ```sql
  mysql> explain select id , age ,phone from tb_user order by age desc,phone desc \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: index
  possible_keys: NULL
            key: idx_user_age_phone
        key_len: 48
            ref: NULL
           rows: 24
       filtered: 100.00
          Extra: Backward index scan; Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  ```

  Backward index scan; Using index：反向扫描索引

  在这个过程中如果违反最左前缀法则，排序时候索引也会失效

  有的时候，我们就是想对一个字段进行升序排序，对另外一个字段进行降序排序，这个时候可以创建索引	

  ```sql
  mysql> create index idx_user_age_phone_ad on tb_user(age asc,phone desc);
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> explain select id , age ,phone from tb_user order by age asc,phone desc \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb_user
     partitions: NULL
           type: index
  possible_keys: NULL
            key: idx_user_age_phone_ad
        key_len: 48
            ref: NULL
           rows: 24
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

  

  - 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
  - 尽量使用覆盖索引
  - 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时候的规则(ASC/DESC)
  - 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区的大小sort_buffer_size（默认是256k）



#### group by优化

主要研究索引对于分组操作的影响

```
#执行分组操作，根据profession字段分组
mysql> select profession,count(*) from tb_user group by profession;
+-----------------------------+----------+
| profession                  | count(*) |
+-----------------------------+----------+
| 会计                        |        1 |
| 化工                        |        2 |
| 国际贸易                    |        1 |
| 土木工程                    |        1 |
| 城市园林                    |        1 |
| 城市规划                    |        2 |
| 工业经济                    |        1 |
| 工程造价                    |        3 |
| 应用数学                    |        2 |
| 无机非金属材料工程            |        1 |
| 机械工程及其自动化            |        1 |
| 舞蹈                        |        1 |
| 英语                        |        1 |
| 软件工程                     |        4 |
| 通讯工程                     |        1 |
| 金属材料                     |        1 |
+-----------------------------+----------+
16 rows in set (0.11 sec)

```





#### limit优化

在一个有800w条数据的表中进行分页查询

```sql
mysql> select * from tb_sku limit 5000000,1\G;
*************************** 1. row ***************************
           id: 5000001
           sn: 100000003145005000001
         name: 华为Meta5000001
        price: 83301
          num: 10000
    alert_num: 100
        image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t23416/164/1114672941/97718/7a52de73/5b51a552Na67d01ef.jpg!q70.jpg.webp
       images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t23416/164/1114672941/97718/7a52de73/5b51a552Na67d01ef.jpg!q70.jpg.webp
       weight: 10
  create_time: 2019-05-01 00:00:00
  update_time: 2019-05-01 00:00:00
category_name: 休闲鞋
   brand_name: 森马
         spec: 白色5000001
     sale_num: 0
  comment_num: 0
       status: 1
1 row in set (4.24 sec)

ERROR: 
No query specified
```

可以看到这个查询语句的执行效率比较低。

`select * from tb_sku limit 5000000,1\G;`这条语句在执行时，MySQL需要排序前5000001条数据，仅仅返回5000001这一条数据，丢弃其他记录，查询排序的代价非常大。

这里的这个优化思路就是，例如现在这个表里面有1000w条数据，如果序号是升序的可以使用两个表联查的方式进行优化

比如说我先在要进行分页查询：

```sql
mysql> select * from tb_sku limit 8000000,2\G;
*************************** 1. row ***************************
           id: 8836955
           sn: 100000003145008836955
         name: 华为Meta8836955
        price: 53955
          num: 10000
    alert_num: 100
        image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t7993/10/987095829/462109/4b41aa39/599939a7N79597505.jpg!q70.jpg.webp
       images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t7993/10/987095829/462109/4b41aa39/599939a7N79597505.jpg!q70.jpg.webp
       weight: 10
  create_time: 2019-05-01 00:00:00
  update_time: 2019-05-01 00:00:00
category_name: 真皮包
   brand_name: 金狐狸
         spec: 白色8836955
     sale_num: 0
  comment_num: 0
       status: 1
*************************** 2. row ***************************
           id: 8836956
           sn: 100000003145008836956
         name: 华为Meta8836956
        price: 33556
          num: 10000
    alert_num: 100
        image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t6118/210/8381393568/198054/a88fb87b/5989079cN13c603a3.jpg!q70.jpg.webp
       images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t6118/210/8381393568/198054/a88fb87b/5989079cN13c603a3.jpg!q70.jpg.webp
       weight: 10
  create_time: 2019-05-01 00:00:00
  update_time: 2019-05-01 00:00:00
category_name: 老花镜
   brand_name: 梅特纳兹
         spec: 白色8836956
     sale_num: 0
  comment_num: 0
       status: 1
2 rows in set (8.16 sec)

ERROR: 
No query specified

```

这个查询语句耗时8.16s

看看语句优化：

```sql
#首先看看仅查询id
mysql> select id  from tb_sku order by id limit 8000000,2;
+---------+
| id      |
+---------+
| 8836955 |
| 8836956 |
+---------+
2 rows in set (5.76 sec)

#进行联查
mysql> select s.* from tb_sku s,(select id  from tb_sku order by id limit 8000000,2) b where s.id=b.id\G;
*************************** 1. row ***************************
           id: 8836955
           sn: 100000003145008836955
         name: 华为Meta8836955
        price: 53955
          num: 10000
    alert_num: 100
        image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t7993/10/987095829/462109/4b41aa39/599939a7N79597505.jpg!q70.jpg.webp
       images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t7993/10/987095829/462109/4b41aa39/599939a7N79597505.jpg!q70.jpg.webp
       weight: 10
  create_time: 2019-05-01 00:00:00
  update_time: 2019-05-01 00:00:00
category_name: 真皮包
   brand_name: 金狐狸
         spec: 白色8836955
     sale_num: 0
  comment_num: 0
       status: 1
*************************** 2. row ***************************
           id: 8836956
           sn: 100000003145008836956
         name: 华为Meta8836956
        price: 33556
          num: 10000
    alert_num: 100
        image: https://m.360buyimg.com/mobilecms/s720x720_jfs/t6118/210/8381393568/198054/a88fb87b/5989079cN13c603a3.jpg!q70.jpg.webp
       images: https://m.360buyimg.com/mobilecms/s720x720_jfs/t6118/210/8381393568/198054/a88fb87b/5989079cN13c603a3.jpg!q70.jpg.webp
       weight: 10
  create_time: 2019-05-01 00:00:00
  update_time: 2019-05-01 00:00:00
category_name: 老花镜
   brand_name: 梅特纳兹
         spec: 白色8836956
     sale_num: 0
  comment_num: 0
       status: 1
2 rows in set (5.26 sec)

ERROR: 
No query specified
```

可以看到，查询效率提高了



#### count优化

MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接放回这个数，效率很高

InnoDB引擎就比较麻烦了，它执行count(*)的时候，需要把数据一行一行的从引擎里面读出来，然后累积计数

优化思路：**自己计数**

- **count的几种用法**

  count()是一个聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是NULL，累计值就+1，否则不加，最后返回累计值。

  对于tb_user表：

  ```
  # 表中的数据数量
  mysql> select count(*) from tb_user;
  +----------+
  | count(*) |
  +----------+
  |       24 |
  +----------+
  1 row in set (0.33 sec)
  
  # 看看id字段数量
  mysql> select count(id) from tb_user;
  +-----------+
  | count(id) |
  +-----------+
  |        24 |
  +-----------+
  1 row in set (0.00 sec)
  
  
  ```

  count只统计该字段不为null值的数量

  - #### count(主键)

    InnoDB引擎会遍历整张表，把每一行的主键id都提取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为NULL）。

  - #### count(字段)

    没有not null约束：InnoDB引擎会遍历整张表，把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，如果不为null，计数累加。

    有not null 约束：InnoDB引擎会遍历整张表把每一行的字段都读取出来，返回给服务层，直接进行累加。

  - #### count(1)

    InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加、

  - #### count(*)

    InnoDB引擎并不会把全部字段都取出来，而是专门做了优化，不取值，服务层直接按行进行累加



#### update优化
